// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package assets

import (
	"fmt"
	"strings"
)

const (
	// AssetNameUSD is a AssetName of type USD.
	AssetNameUSD AssetName = "USD"
	// AssetNameUSDC is a AssetName of type USDC.
	AssetNameUSDC AssetName = "USDC"
	// AssetNameUSDT is a AssetName of type USDT.
	AssetNameUSDT AssetName = "USDT"
	// AssetNamePYUSD is a AssetName of type PYUSD.
	AssetNamePYUSD AssetName = "PYUSD"
	// AssetNameRLUSD is a AssetName of type RLUSD.
	AssetNameRLUSD AssetName = "RLUSD"
	// AssetNameUSDG is a AssetName of type USDG.
	AssetNameUSDG AssetName = "USDG"
	// AssetNameUSDP is a AssetName of type USDP.
	AssetNameUSDP AssetName = "USDP"
	// AssetNameEURC is a AssetName of type EURC.
	AssetNameEURC AssetName = "EURC"
	// AssetNameMXNB is a AssetName of type MXNB.
	AssetNameMXNB AssetName = "MXNB"
)

var ErrInvalidAssetName = fmt.Errorf("not a valid AssetName, try [%s]", strings.Join(_AssetNameNames, ", "))

var _AssetNameNames = []string{
	string(AssetNameUSD),
	string(AssetNameUSDC),
	string(AssetNameUSDT),
	string(AssetNamePYUSD),
	string(AssetNameRLUSD),
	string(AssetNameUSDG),
	string(AssetNameUSDP),
	string(AssetNameEURC),
	string(AssetNameMXNB),
}

// AssetNameNames returns a list of possible string values of AssetName.
func AssetNameNames() []string {
	tmp := make([]string, len(_AssetNameNames))
	copy(tmp, _AssetNameNames)
	return tmp
}

// String implements the Stringer interface.
func (x AssetName) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AssetName) IsValid() bool {
	_, err := ParseAssetName(string(x))
	return err == nil
}

var _AssetNameValue = map[string]AssetName{
	"USD":   AssetNameUSD,
	"usd":   AssetNameUSD,
	"USDC":  AssetNameUSDC,
	"usdc":  AssetNameUSDC,
	"USDT":  AssetNameUSDT,
	"usdt":  AssetNameUSDT,
	"PYUSD": AssetNamePYUSD,
	"pyusd": AssetNamePYUSD,
	"RLUSD": AssetNameRLUSD,
	"rlusd": AssetNameRLUSD,
	"USDG":  AssetNameUSDG,
	"usdg":  AssetNameUSDG,
	"USDP":  AssetNameUSDP,
	"usdp":  AssetNameUSDP,
	"EURC":  AssetNameEURC,
	"eurc":  AssetNameEURC,
	"MXNB":  AssetNameMXNB,
	"mxnb":  AssetNameMXNB,
}

// ParseAssetName attempts to convert a string to a AssetName.
func ParseAssetName(name string) (AssetName, error) {
	if x, ok := _AssetNameValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AssetNameValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AssetName(""), fmt.Errorf("%s is %w", name, ErrInvalidAssetName)
}

// MarshalText implements the text marshaller method.
func (x AssetName) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AssetName) UnmarshalText(text []byte) error {
	tmp, err := ParseAssetName(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AssetName) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// NetworkNameUSACH is a NetworkName of type US_ACH.
	NetworkNameUSACH NetworkName = "US_ACH"
	// NetworkNameSWIFT is a NetworkName of type SWIFT.
	NetworkNameSWIFT NetworkName = "SWIFT"
	// NetworkNameUSFEDWIRE is a NetworkName of type US_FEDWIRE.
	NetworkNameUSFEDWIRE NetworkName = "US_FEDWIRE"
	// NetworkNameARBITRUM is a NetworkName of type ARBITRUM.
	NetworkNameARBITRUM NetworkName = "ARBITRUM"
	// NetworkNameAVALANCHE is a NetworkName of type AVALANCHE.
	NetworkNameAVALANCHE NetworkName = "AVALANCHE"
	// NetworkNameBASE is a NetworkName of type BASE.
	NetworkNameBASE NetworkName = "BASE"
	// NetworkNameBNBCHAIN is a NetworkName of type BNBCHAIN.
	NetworkNameBNBCHAIN NetworkName = "BNBCHAIN"
	// NetworkNameETHEREUM is a NetworkName of type ETHEREUM.
	NetworkNameETHEREUM NetworkName = "ETHEREUM"
	// NetworkNamePOLYGON is a NetworkName of type POLYGON.
	NetworkNamePOLYGON NetworkName = "POLYGON"
	// NetworkNameSOLANA is a NetworkName of type SOLANA.
	NetworkNameSOLANA NetworkName = "SOLANA"
)

var ErrInvalidNetworkName = fmt.Errorf("not a valid NetworkName, try [%s]", strings.Join(_NetworkNameNames, ", "))

var _NetworkNameNames = []string{
	string(NetworkNameUSACH),
	string(NetworkNameSWIFT),
	string(NetworkNameUSFEDWIRE),
	string(NetworkNameARBITRUM),
	string(NetworkNameAVALANCHE),
	string(NetworkNameBASE),
	string(NetworkNameBNBCHAIN),
	string(NetworkNameETHEREUM),
	string(NetworkNamePOLYGON),
	string(NetworkNameSOLANA),
}

// NetworkNameNames returns a list of possible string values of NetworkName.
func NetworkNameNames() []string {
	tmp := make([]string, len(_NetworkNameNames))
	copy(tmp, _NetworkNameNames)
	return tmp
}

// String implements the Stringer interface.
func (x NetworkName) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NetworkName) IsValid() bool {
	_, err := ParseNetworkName(string(x))
	return err == nil
}

var _NetworkNameValue = map[string]NetworkName{
	"US_ACH":     NetworkNameUSACH,
	"us_ach":     NetworkNameUSACH,
	"SWIFT":      NetworkNameSWIFT,
	"swift":      NetworkNameSWIFT,
	"US_FEDWIRE": NetworkNameUSFEDWIRE,
	"us_fedwire": NetworkNameUSFEDWIRE,
	"ARBITRUM":   NetworkNameARBITRUM,
	"arbitrum":   NetworkNameARBITRUM,
	"AVALANCHE":  NetworkNameAVALANCHE,
	"avalanche":  NetworkNameAVALANCHE,
	"BASE":       NetworkNameBASE,
	"base":       NetworkNameBASE,
	"BNBCHAIN":   NetworkNameBNBCHAIN,
	"bnbchain":   NetworkNameBNBCHAIN,
	"ETHEREUM":   NetworkNameETHEREUM,
	"ethereum":   NetworkNameETHEREUM,
	"POLYGON":    NetworkNamePOLYGON,
	"polygon":    NetworkNamePOLYGON,
	"SOLANA":     NetworkNameSOLANA,
	"solana":     NetworkNameSOLANA,
}

// ParseNetworkName attempts to convert a string to a NetworkName.
func ParseNetworkName(name string) (NetworkName, error) {
	if x, ok := _NetworkNameValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _NetworkNameValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return NetworkName(""), fmt.Errorf("%s is %w", name, ErrInvalidNetworkName)
}

// MarshalText implements the text marshaller method.
func (x NetworkName) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NetworkName) UnmarshalText(text []byte) error {
	tmp, err := ParseNetworkName(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *NetworkName) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SortOrderASC is a SortOrder of type ASC.
	SortOrderASC SortOrder = "ASC"
	// SortOrderDESC is a SortOrder of type DESC.
	SortOrderDESC SortOrder = "DESC"
)

var ErrInvalidSortOrder = fmt.Errorf("not a valid SortOrder, try [%s]", strings.Join(_SortOrderNames, ", "))

var _SortOrderNames = []string{
	string(SortOrderASC),
	string(SortOrderDESC),
}

// SortOrderNames returns a list of possible string values of SortOrder.
func SortOrderNames() []string {
	tmp := make([]string, len(_SortOrderNames))
	copy(tmp, _SortOrderNames)
	return tmp
}

// String implements the Stringer interface.
func (x SortOrder) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SortOrder) IsValid() bool {
	_, err := ParseSortOrder(string(x))
	return err == nil
}

var _SortOrderValue = map[string]SortOrder{
	"ASC":  SortOrderASC,
	"asc":  SortOrderASC,
	"DESC": SortOrderDESC,
	"desc": SortOrderDESC,
}

// ParseSortOrder attempts to convert a string to a SortOrder.
func ParseSortOrder(name string) (SortOrder, error) {
	if x, ok := _SortOrderValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SortOrderValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SortOrder(""), fmt.Errorf("%s is %w", name, ErrInvalidSortOrder)
}

// MarshalText implements the text marshaller method.
func (x SortOrder) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SortOrder) UnmarshalText(text []byte) error {
	tmp, err := ParseSortOrder(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SortOrder) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
