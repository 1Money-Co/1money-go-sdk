// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package transactions

import (
	"fmt"
	"strings"
)

const (
	// TransactionActionDEPOSIT is a TransactionAction of type DEPOSIT.
	TransactionActionDEPOSIT TransactionAction = "DEPOSIT"
	// TransactionActionWITHDRAWAL is a TransactionAction of type WITHDRAWAL.
	TransactionActionWITHDRAWAL TransactionAction = "WITHDRAWAL"
	// TransactionActionCONVERSION is a TransactionAction of type CONVERSION.
	TransactionActionCONVERSION TransactionAction = "CONVERSION"
)

var ErrInvalidTransactionAction = fmt.Errorf("not a valid TransactionAction, try [%s]", strings.Join(_TransactionActionNames, ", "))

var _TransactionActionNames = []string{
	string(TransactionActionDEPOSIT),
	string(TransactionActionWITHDRAWAL),
	string(TransactionActionCONVERSION),
}

// TransactionActionNames returns a list of possible string values of TransactionAction.
func TransactionActionNames() []string {
	tmp := make([]string, len(_TransactionActionNames))
	copy(tmp, _TransactionActionNames)
	return tmp
}

// String implements the Stringer interface.
func (x TransactionAction) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TransactionAction) IsValid() bool {
	_, err := ParseTransactionAction(string(x))
	return err == nil
}

var _TransactionActionValue = map[string]TransactionAction{
	"DEPOSIT":    TransactionActionDEPOSIT,
	"deposit":    TransactionActionDEPOSIT,
	"WITHDRAWAL": TransactionActionWITHDRAWAL,
	"withdrawal": TransactionActionWITHDRAWAL,
	"CONVERSION": TransactionActionCONVERSION,
	"conversion": TransactionActionCONVERSION,
}

// ParseTransactionAction attempts to convert a string to a TransactionAction.
func ParseTransactionAction(name string) (TransactionAction, error) {
	if x, ok := _TransactionActionValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TransactionActionValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TransactionAction(""), fmt.Errorf("%s is %w", name, ErrInvalidTransactionAction)
}

// MarshalText implements the text marshaller method.
func (x TransactionAction) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TransactionAction) UnmarshalText(text []byte) error {
	tmp, err := ParseTransactionAction(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TransactionAction) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TransactionStatusPENDING is a TransactionStatus of type PENDING.
	TransactionStatusPENDING TransactionStatus = "PENDING"
	// TransactionStatusCOMPLETED is a TransactionStatus of type COMPLETED.
	TransactionStatusCOMPLETED TransactionStatus = "COMPLETED"
	// TransactionStatusFAILED is a TransactionStatus of type FAILED.
	TransactionStatusFAILED TransactionStatus = "FAILED"
	// TransactionStatusREVERSED is a TransactionStatus of type REVERSED.
	TransactionStatusREVERSED TransactionStatus = "REVERSED"
)

var ErrInvalidTransactionStatus = fmt.Errorf("not a valid TransactionStatus, try [%s]", strings.Join(_TransactionStatusNames, ", "))

var _TransactionStatusNames = []string{
	string(TransactionStatusPENDING),
	string(TransactionStatusCOMPLETED),
	string(TransactionStatusFAILED),
	string(TransactionStatusREVERSED),
}

// TransactionStatusNames returns a list of possible string values of TransactionStatus.
func TransactionStatusNames() []string {
	tmp := make([]string, len(_TransactionStatusNames))
	copy(tmp, _TransactionStatusNames)
	return tmp
}

// String implements the Stringer interface.
func (x TransactionStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TransactionStatus) IsValid() bool {
	_, err := ParseTransactionStatus(string(x))
	return err == nil
}

var _TransactionStatusValue = map[string]TransactionStatus{
	"PENDING":   TransactionStatusPENDING,
	"pending":   TransactionStatusPENDING,
	"COMPLETED": TransactionStatusCOMPLETED,
	"completed": TransactionStatusCOMPLETED,
	"FAILED":    TransactionStatusFAILED,
	"failed":    TransactionStatusFAILED,
	"REVERSED":  TransactionStatusREVERSED,
	"reversed":  TransactionStatusREVERSED,
}

// ParseTransactionStatus attempts to convert a string to a TransactionStatus.
func ParseTransactionStatus(name string) (TransactionStatus, error) {
	if x, ok := _TransactionStatusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TransactionStatusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TransactionStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidTransactionStatus)
}

// MarshalText implements the text marshaller method.
func (x TransactionStatus) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TransactionStatus) UnmarshalText(text []byte) error {
	tmp, err := ParseTransactionStatus(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TransactionStatus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
