// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package customer

import (
	"fmt"
	"strings"
)

const (
	// AccountPurposeCharitableDonations is a AccountPurpose of type charitable_donations.
	AccountPurposeCharitableDonations AccountPurpose = "charitable_donations"
	// AccountPurposeEcommerceRetailPayments is a AccountPurpose of type ecommerce_retail_payments.
	AccountPurposeEcommerceRetailPayments AccountPurpose = "ecommerce_retail_payments"
	// AccountPurposeInvestmentPurposes is a AccountPurpose of type investment_purposes.
	AccountPurposeInvestmentPurposes AccountPurpose = "investment_purposes"
	// AccountPurposeOther is a AccountPurpose of type other.
	AccountPurposeOther AccountPurpose = "other"
	// AccountPurposePaymentsToFriendsOrFamilyAbroad is a AccountPurpose of type payments_to_friends_or_family_abroad.
	AccountPurposePaymentsToFriendsOrFamilyAbroad AccountPurpose = "payments_to_friends_or_family_abroad"
	// AccountPurposePayroll is a AccountPurpose of type payroll.
	AccountPurposePayroll AccountPurpose = "payroll"
	// AccountPurposePersonalOrLivingExpenses is a AccountPurpose of type personal_or_living_expenses.
	AccountPurposePersonalOrLivingExpenses AccountPurpose = "personal_or_living_expenses"
	// AccountPurposeProtectWealth is a AccountPurpose of type protect_wealth.
	AccountPurposeProtectWealth AccountPurpose = "protect_wealth"
	// AccountPurposePurchaseGoodsAndServices is a AccountPurpose of type purchase_goods_and_services.
	AccountPurposePurchaseGoodsAndServices AccountPurpose = "purchase_goods_and_services"
	// AccountPurposeReceivePaymentsForGoodsAndServices is a AccountPurpose of type receive_payments_for_goods_and_services.
	AccountPurposeReceivePaymentsForGoodsAndServices AccountPurpose = "receive_payments_for_goods_and_services"
	// AccountPurposeTaxOptimization is a AccountPurpose of type tax_optimization.
	AccountPurposeTaxOptimization AccountPurpose = "tax_optimization"
	// AccountPurposeThirdPartyMoneyTransmission is a AccountPurpose of type third_party_money_transmission.
	AccountPurposeThirdPartyMoneyTransmission AccountPurpose = "third_party_money_transmission"
	// AccountPurposeTreasuryManagement is a AccountPurpose of type treasury_management.
	AccountPurposeTreasuryManagement AccountPurpose = "treasury_management"
)

var ErrInvalidAccountPurpose = fmt.Errorf("not a valid AccountPurpose, try [%s]", strings.Join(_AccountPurposeNames, ", "))

var _AccountPurposeNames = []string{
	string(AccountPurposeCharitableDonations),
	string(AccountPurposeEcommerceRetailPayments),
	string(AccountPurposeInvestmentPurposes),
	string(AccountPurposeOther),
	string(AccountPurposePaymentsToFriendsOrFamilyAbroad),
	string(AccountPurposePayroll),
	string(AccountPurposePersonalOrLivingExpenses),
	string(AccountPurposeProtectWealth),
	string(AccountPurposePurchaseGoodsAndServices),
	string(AccountPurposeReceivePaymentsForGoodsAndServices),
	string(AccountPurposeTaxOptimization),
	string(AccountPurposeThirdPartyMoneyTransmission),
	string(AccountPurposeTreasuryManagement),
}

// AccountPurposeNames returns a list of possible string values of AccountPurpose.
func AccountPurposeNames() []string {
	tmp := make([]string, len(_AccountPurposeNames))
	copy(tmp, _AccountPurposeNames)
	return tmp
}

// String implements the Stringer interface.
func (x AccountPurpose) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AccountPurpose) IsValid() bool {
	_, err := ParseAccountPurpose(string(x))
	return err == nil
}

var _AccountPurposeValue = map[string]AccountPurpose{
	"charitable_donations":                    AccountPurposeCharitableDonations,
	"ecommerce_retail_payments":               AccountPurposeEcommerceRetailPayments,
	"investment_purposes":                     AccountPurposeInvestmentPurposes,
	"other":                                   AccountPurposeOther,
	"payments_to_friends_or_family_abroad":    AccountPurposePaymentsToFriendsOrFamilyAbroad,
	"payroll":                                 AccountPurposePayroll,
	"personal_or_living_expenses":             AccountPurposePersonalOrLivingExpenses,
	"protect_wealth":                          AccountPurposeProtectWealth,
	"purchase_goods_and_services":             AccountPurposePurchaseGoodsAndServices,
	"receive_payments_for_goods_and_services": AccountPurposeReceivePaymentsForGoodsAndServices,
	"tax_optimization":                        AccountPurposeTaxOptimization,
	"third_party_money_transmission":          AccountPurposeThirdPartyMoneyTransmission,
	"treasury_management":                     AccountPurposeTreasuryManagement,
}

// ParseAccountPurpose attempts to convert a string to a AccountPurpose.
func ParseAccountPurpose(name string) (AccountPurpose, error) {
	if x, ok := _AccountPurposeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AccountPurposeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AccountPurpose(""), fmt.Errorf("%s is %w", name, ErrInvalidAccountPurpose)
}

// MarshalText implements the text marshaller method.
func (x AccountPurpose) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AccountPurpose) UnmarshalText(text []byte) error {
	tmp, err := ParseAccountPurpose(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AccountPurpose) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// BusinessTypeCooperative is a BusinessType of type cooperative.
	BusinessTypeCooperative BusinessType = "cooperative"
	// BusinessTypeCorporation is a BusinessType of type corporation.
	BusinessTypeCorporation BusinessType = "corporation"
	// BusinessTypeLlc is a BusinessType of type llc.
	BusinessTypeLlc BusinessType = "llc"
	// BusinessTypePartnership is a BusinessType of type partnership.
	BusinessTypePartnership BusinessType = "partnership"
	// BusinessTypeSoleProprietorship is a BusinessType of type sole_proprietorship.
	BusinessTypeSoleProprietorship BusinessType = "sole_proprietorship"
)

var ErrInvalidBusinessType = fmt.Errorf("not a valid BusinessType, try [%s]", strings.Join(_BusinessTypeNames, ", "))

var _BusinessTypeNames = []string{
	string(BusinessTypeCooperative),
	string(BusinessTypeCorporation),
	string(BusinessTypeLlc),
	string(BusinessTypePartnership),
	string(BusinessTypeSoleProprietorship),
}

// BusinessTypeNames returns a list of possible string values of BusinessType.
func BusinessTypeNames() []string {
	tmp := make([]string, len(_BusinessTypeNames))
	copy(tmp, _BusinessTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x BusinessType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BusinessType) IsValid() bool {
	_, err := ParseBusinessType(string(x))
	return err == nil
}

var _BusinessTypeValue = map[string]BusinessType{
	"cooperative":         BusinessTypeCooperative,
	"corporation":         BusinessTypeCorporation,
	"llc":                 BusinessTypeLlc,
	"partnership":         BusinessTypePartnership,
	"sole_proprietorship": BusinessTypeSoleProprietorship,
}

// ParseBusinessType attempts to convert a string to a BusinessType.
func ParseBusinessType(name string) (BusinessType, error) {
	if x, ok := _BusinessTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BusinessTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BusinessType(""), fmt.Errorf("%s is %w", name, ErrInvalidBusinessType)
}

// MarshalText implements the text marshaller method.
func (x BusinessType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BusinessType) UnmarshalText(text []byte) error {
	tmp, err := ParseBusinessType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BusinessType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// DocumentTypeAmlComfortLetter is a DocumentType of type aml_comfort_letter.
	DocumentTypeAmlComfortLetter DocumentType = "aml_comfort_letter"
	// DocumentTypeConstitutionalDocument is a DocumentType of type constitutional_document.
	DocumentTypeConstitutionalDocument DocumentType = "constitutional_document"
	// DocumentTypeDirectorsRegistry is a DocumentType of type directors_registry.
	DocumentTypeDirectorsRegistry DocumentType = "directors_registry"
	// DocumentTypeESignatureCertificate is a DocumentType of type e_signature_certificate.
	DocumentTypeESignatureCertificate DocumentType = "e_signature_certificate"
	// DocumentTypeEvidenceOfGoodStanding is a DocumentType of type evidence_of_good_standing.
	DocumentTypeEvidenceOfGoodStanding DocumentType = "evidence_of_good_standing"
	// DocumentTypeFlowOfFunds is a DocumentType of type flow_of_funds.
	DocumentTypeFlowOfFunds DocumentType = "flow_of_funds"
	// DocumentTypeFormationDocument is a DocumentType of type formation_document.
	DocumentTypeFormationDocument DocumentType = "formation_document"
	// DocumentTypeMarketingMaterials is a DocumentType of type marketing_materials.
	DocumentTypeMarketingMaterials DocumentType = "marketing_materials"
	// DocumentTypeOther is a DocumentType of type other.
	DocumentTypeOther DocumentType = "other"
	// DocumentTypeOwnershipChart is a DocumentType of type ownership_chart.
	DocumentTypeOwnershipChart DocumentType = "ownership_chart"
	// DocumentTypeOwnershipInformation is a DocumentType of type ownership_information.
	DocumentTypeOwnershipInformation DocumentType = "ownership_information"
	// DocumentTypeProofOfAccountPurpose is a DocumentType of type proof_of_account_purpose.
	DocumentTypeProofOfAccountPurpose DocumentType = "proof_of_account_purpose"
	// DocumentTypeProofOfAddress is a DocumentType of type proof_of_address.
	DocumentTypeProofOfAddress DocumentType = "proof_of_address"
	// DocumentTypeProofOfEntityNameChange is a DocumentType of type proof_of_entity_name_change.
	DocumentTypeProofOfEntityNameChange DocumentType = "proof_of_entity_name_change"
	// DocumentTypeProofOfNatureOfBusiness is a DocumentType of type proof_of_nature_of_business.
	DocumentTypeProofOfNatureOfBusiness DocumentType = "proof_of_nature_of_business"
	// DocumentTypeProofOfSignatoryAuthority is a DocumentType of type proof_of_signatory_authority.
	DocumentTypeProofOfSignatoryAuthority DocumentType = "proof_of_signatory_authority"
	// DocumentTypeProofOfSourceOfFunds is a DocumentType of type proof_of_source_of_funds.
	DocumentTypeProofOfSourceOfFunds DocumentType = "proof_of_source_of_funds"
	// DocumentTypeProofOfSourceOfWealth is a DocumentType of type proof_of_source_of_wealth.
	DocumentTypeProofOfSourceOfWealth DocumentType = "proof_of_source_of_wealth"
	// DocumentTypeProofOfTaxIdentification is a DocumentType of type proof_of_tax_identification.
	DocumentTypeProofOfTaxIdentification DocumentType = "proof_of_tax_identification"
	// DocumentTypeRegistrationDocument is a DocumentType of type registration_document.
	DocumentTypeRegistrationDocument DocumentType = "registration_document"
	// DocumentTypeShareholderRegister is a DocumentType of type shareholder_register.
	DocumentTypeShareholderRegister DocumentType = "shareholder_register"
)

var ErrInvalidDocumentType = fmt.Errorf("not a valid DocumentType, try [%s]", strings.Join(_DocumentTypeNames, ", "))

var _DocumentTypeNames = []string{
	string(DocumentTypeAmlComfortLetter),
	string(DocumentTypeConstitutionalDocument),
	string(DocumentTypeDirectorsRegistry),
	string(DocumentTypeESignatureCertificate),
	string(DocumentTypeEvidenceOfGoodStanding),
	string(DocumentTypeFlowOfFunds),
	string(DocumentTypeFormationDocument),
	string(DocumentTypeMarketingMaterials),
	string(DocumentTypeOther),
	string(DocumentTypeOwnershipChart),
	string(DocumentTypeOwnershipInformation),
	string(DocumentTypeProofOfAccountPurpose),
	string(DocumentTypeProofOfAddress),
	string(DocumentTypeProofOfEntityNameChange),
	string(DocumentTypeProofOfNatureOfBusiness),
	string(DocumentTypeProofOfSignatoryAuthority),
	string(DocumentTypeProofOfSourceOfFunds),
	string(DocumentTypeProofOfSourceOfWealth),
	string(DocumentTypeProofOfTaxIdentification),
	string(DocumentTypeRegistrationDocument),
	string(DocumentTypeShareholderRegister),
}

// DocumentTypeNames returns a list of possible string values of DocumentType.
func DocumentTypeNames() []string {
	tmp := make([]string, len(_DocumentTypeNames))
	copy(tmp, _DocumentTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x DocumentType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DocumentType) IsValid() bool {
	_, err := ParseDocumentType(string(x))
	return err == nil
}

var _DocumentTypeValue = map[string]DocumentType{
	"aml_comfort_letter":           DocumentTypeAmlComfortLetter,
	"constitutional_document":      DocumentTypeConstitutionalDocument,
	"directors_registry":           DocumentTypeDirectorsRegistry,
	"e_signature_certificate":      DocumentTypeESignatureCertificate,
	"evidence_of_good_standing":    DocumentTypeEvidenceOfGoodStanding,
	"flow_of_funds":                DocumentTypeFlowOfFunds,
	"formation_document":           DocumentTypeFormationDocument,
	"marketing_materials":          DocumentTypeMarketingMaterials,
	"other":                        DocumentTypeOther,
	"ownership_chart":              DocumentTypeOwnershipChart,
	"ownership_information":        DocumentTypeOwnershipInformation,
	"proof_of_account_purpose":     DocumentTypeProofOfAccountPurpose,
	"proof_of_address":             DocumentTypeProofOfAddress,
	"proof_of_entity_name_change":  DocumentTypeProofOfEntityNameChange,
	"proof_of_nature_of_business":  DocumentTypeProofOfNatureOfBusiness,
	"proof_of_signatory_authority": DocumentTypeProofOfSignatoryAuthority,
	"proof_of_source_of_funds":     DocumentTypeProofOfSourceOfFunds,
	"proof_of_source_of_wealth":    DocumentTypeProofOfSourceOfWealth,
	"proof_of_tax_identification":  DocumentTypeProofOfTaxIdentification,
	"registration_document":        DocumentTypeRegistrationDocument,
	"shareholder_register":         DocumentTypeShareholderRegister,
}

// ParseDocumentType attempts to convert a string to a DocumentType.
func ParseDocumentType(name string) (DocumentType, error) {
	if x, ok := _DocumentTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _DocumentTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return DocumentType(""), fmt.Errorf("%s is %w", name, ErrInvalidDocumentType)
}

// MarshalText implements the text marshaller method.
func (x DocumentType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DocumentType) UnmarshalText(text []byte) error {
	tmp, err := ParseDocumentType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *DocumentType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// FileFormatJpeg is a FileFormat of type jpeg.
	FileFormatJpeg FileFormat = "jpeg"
	// FileFormatJpg is a FileFormat of type jpg.
	FileFormatJpg FileFormat = "jpg"
	// FileFormatPng is a FileFormat of type png.
	FileFormatPng FileFormat = "png"
	// FileFormatHeic is a FileFormat of type heic.
	FileFormatHeic FileFormat = "heic"
	// FileFormatTif is a FileFormat of type tif.
	FileFormatTif FileFormat = "tif"
	// FileFormatPdf is a FileFormat of type pdf.
	FileFormatPdf FileFormat = "pdf"
	// FileFormatCsv is a FileFormat of type csv.
	FileFormatCsv FileFormat = "csv"
	// FileFormatXls is a FileFormat of type xls.
	FileFormatXls FileFormat = "xls"
	// FileFormatXlsx is a FileFormat of type xlsx.
	FileFormatXlsx FileFormat = "xlsx"
)

var ErrInvalidFileFormat = fmt.Errorf("not a valid FileFormat, try [%s]", strings.Join(_FileFormatNames, ", "))

var _FileFormatNames = []string{
	string(FileFormatJpeg),
	string(FileFormatJpg),
	string(FileFormatPng),
	string(FileFormatHeic),
	string(FileFormatTif),
	string(FileFormatPdf),
	string(FileFormatCsv),
	string(FileFormatXls),
	string(FileFormatXlsx),
}

// FileFormatNames returns a list of possible string values of FileFormat.
func FileFormatNames() []string {
	tmp := make([]string, len(_FileFormatNames))
	copy(tmp, _FileFormatNames)
	return tmp
}

// String implements the Stringer interface.
func (x FileFormat) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FileFormat) IsValid() bool {
	_, err := ParseFileFormat(string(x))
	return err == nil
}

var _FileFormatValue = map[string]FileFormat{
	"jpeg": FileFormatJpeg,
	"jpg":  FileFormatJpg,
	"png":  FileFormatPng,
	"heic": FileFormatHeic,
	"tif":  FileFormatTif,
	"pdf":  FileFormatPdf,
	"csv":  FileFormatCsv,
	"xls":  FileFormatXls,
	"xlsx": FileFormatXlsx,
}

// ParseFileFormat attempts to convert a string to a FileFormat.
func ParseFileFormat(name string) (FileFormat, error) {
	if x, ok := _FileFormatValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _FileFormatValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return FileFormat(""), fmt.Errorf("%s is %w", name, ErrInvalidFileFormat)
}

// MarshalText implements the text marshaller method.
func (x FileFormat) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FileFormat) UnmarshalText(text []byte) error {
	tmp, err := ParseFileFormat(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *FileFormat) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// GenderMale is a Gender of type male.
	GenderMale Gender = "male"
	// GenderFemale is a Gender of type female.
	GenderFemale Gender = "female"
)

var ErrInvalidGender = fmt.Errorf("not a valid Gender, try [%s]", strings.Join(_GenderNames, ", "))

var _GenderNames = []string{
	string(GenderMale),
	string(GenderFemale),
}

// GenderNames returns a list of possible string values of Gender.
func GenderNames() []string {
	tmp := make([]string, len(_GenderNames))
	copy(tmp, _GenderNames)
	return tmp
}

// String implements the Stringer interface.
func (x Gender) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Gender) IsValid() bool {
	_, err := ParseGender(string(x))
	return err == nil
}

var _GenderValue = map[string]Gender{
	"male":   GenderMale,
	"female": GenderFemale,
}

// ParseGender attempts to convert a string to a Gender.
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _GenderValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Gender(""), fmt.Errorf("%s is %w", name, ErrInvalidGender)
}

// MarshalText implements the text marshaller method.
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Gender) UnmarshalText(text []byte) error {
	tmp, err := ParseGender(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Gender) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// HighRiskActivityAdultEntertainment is a HighRiskActivity of type adult_entertainment.
	HighRiskActivityAdultEntertainment HighRiskActivity = "adult_entertainment"
	// HighRiskActivityCannabis is a HighRiskActivity of type cannabis.
	HighRiskActivityCannabis HighRiskActivity = "cannabis"
	// HighRiskActivityCryptocurrency is a HighRiskActivity of type cryptocurrency.
	HighRiskActivityCryptocurrency HighRiskActivity = "cryptocurrency"
	// HighRiskActivityGambling is a HighRiskActivity of type gambling.
	HighRiskActivityGambling HighRiskActivity = "gambling"
	// HighRiskActivityMoneyServices is a HighRiskActivity of type money_services.
	HighRiskActivityMoneyServices HighRiskActivity = "money_services"
	// HighRiskActivityPreciousMetals is a HighRiskActivity of type precious_metals.
	HighRiskActivityPreciousMetals HighRiskActivity = "precious_metals"
	// HighRiskActivityWeapons is a HighRiskActivity of type weapons.
	HighRiskActivityWeapons HighRiskActivity = "weapons"
	// HighRiskActivityNone is a HighRiskActivity of type none.
	HighRiskActivityNone HighRiskActivity = "none"
)

var ErrInvalidHighRiskActivity = fmt.Errorf("not a valid HighRiskActivity, try [%s]", strings.Join(_HighRiskActivityNames, ", "))

var _HighRiskActivityNames = []string{
	string(HighRiskActivityAdultEntertainment),
	string(HighRiskActivityCannabis),
	string(HighRiskActivityCryptocurrency),
	string(HighRiskActivityGambling),
	string(HighRiskActivityMoneyServices),
	string(HighRiskActivityPreciousMetals),
	string(HighRiskActivityWeapons),
	string(HighRiskActivityNone),
}

// HighRiskActivityNames returns a list of possible string values of HighRiskActivity.
func HighRiskActivityNames() []string {
	tmp := make([]string, len(_HighRiskActivityNames))
	copy(tmp, _HighRiskActivityNames)
	return tmp
}

// String implements the Stringer interface.
func (x HighRiskActivity) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HighRiskActivity) IsValid() bool {
	_, err := ParseHighRiskActivity(string(x))
	return err == nil
}

var _HighRiskActivityValue = map[string]HighRiskActivity{
	"adult_entertainment": HighRiskActivityAdultEntertainment,
	"cannabis":            HighRiskActivityCannabis,
	"cryptocurrency":      HighRiskActivityCryptocurrency,
	"gambling":            HighRiskActivityGambling,
	"money_services":      HighRiskActivityMoneyServices,
	"precious_metals":     HighRiskActivityPreciousMetals,
	"weapons":             HighRiskActivityWeapons,
	"none":                HighRiskActivityNone,
}

// ParseHighRiskActivity attempts to convert a string to a HighRiskActivity.
func ParseHighRiskActivity(name string) (HighRiskActivity, error) {
	if x, ok := _HighRiskActivityValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HighRiskActivityValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HighRiskActivity(""), fmt.Errorf("%s is %w", name, ErrInvalidHighRiskActivity)
}

// MarshalText implements the text marshaller method.
func (x HighRiskActivity) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *HighRiskActivity) UnmarshalText(text []byte) error {
	tmp, err := ParseHighRiskActivity(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *HighRiskActivity) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// IDTypeDriversLicense is a IDType of type drivers_license.
	IDTypeDriversLicense IDType = "drivers_license"
	// IDTypePassport is a IDType of type passport.
	IDTypePassport IDType = "passport"
	// IDTypeNationalId is a IDType of type national_id.
	IDTypeNationalId IDType = "national_id"
	// IDTypeStateId is a IDType of type state_id.
	IDTypeStateId IDType = "state_id"
)

var ErrInvalidIDType = fmt.Errorf("not a valid IDType, try [%s]", strings.Join(_IDTypeNames, ", "))

var _IDTypeNames = []string{
	string(IDTypeDriversLicense),
	string(IDTypePassport),
	string(IDTypeNationalId),
	string(IDTypeStateId),
}

// IDTypeNames returns a list of possible string values of IDType.
func IDTypeNames() []string {
	tmp := make([]string, len(_IDTypeNames))
	copy(tmp, _IDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x IDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x IDType) IsValid() bool {
	_, err := ParseIDType(string(x))
	return err == nil
}

var _IDTypeValue = map[string]IDType{
	"drivers_license": IDTypeDriversLicense,
	"passport":        IDTypePassport,
	"national_id":     IDTypeNationalId,
	"state_id":        IDTypeStateId,
}

// ParseIDType attempts to convert a string to a IDType.
func ParseIDType(name string) (IDType, error) {
	if x, ok := _IDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _IDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return IDType(""), fmt.Errorf("%s is %w", name, ErrInvalidIDType)
}

// MarshalText implements the text marshaller method.
func (x IDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *IDType) UnmarshalText(text []byte) error {
	tmp, err := ParseIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *IDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageFormatJpeg is a ImageFormat of type jpeg.
	ImageFormatJpeg ImageFormat = "jpeg"
	// ImageFormatJpg is a ImageFormat of type jpg.
	ImageFormatJpg ImageFormat = "jpg"
	// ImageFormatPng is a ImageFormat of type png.
	ImageFormatPng ImageFormat = "png"
	// ImageFormatHeic is a ImageFormat of type heic.
	ImageFormatHeic ImageFormat = "heic"
	// ImageFormatTif is a ImageFormat of type tif.
	ImageFormatTif ImageFormat = "tif"
)

var ErrInvalidImageFormat = fmt.Errorf("not a valid ImageFormat, try [%s]", strings.Join(_ImageFormatNames, ", "))

var _ImageFormatNames = []string{
	string(ImageFormatJpeg),
	string(ImageFormatJpg),
	string(ImageFormatPng),
	string(ImageFormatHeic),
	string(ImageFormatTif),
}

// ImageFormatNames returns a list of possible string values of ImageFormat.
func ImageFormatNames() []string {
	tmp := make([]string, len(_ImageFormatNames))
	copy(tmp, _ImageFormatNames)
	return tmp
}

// String implements the Stringer interface.
func (x ImageFormat) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageFormat) IsValid() bool {
	_, err := ParseImageFormat(string(x))
	return err == nil
}

var _ImageFormatValue = map[string]ImageFormat{
	"jpeg": ImageFormatJpeg,
	"jpg":  ImageFormatJpg,
	"png":  ImageFormatPng,
	"heic": ImageFormatHeic,
	"tif":  ImageFormatTif,
}

// ParseImageFormat attempts to convert a string to a ImageFormat.
func ParseImageFormat(name string) (ImageFormat, error) {
	if x, ok := _ImageFormatValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ImageFormatValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ImageFormat(""), fmt.Errorf("%s is %w", name, ErrInvalidImageFormat)
}

// MarshalText implements the text marshaller method.
func (x ImageFormat) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageFormat) UnmarshalText(text []byte) error {
	tmp, err := ParseImageFormat(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageFormat) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// KybStatusInit is a KybStatus of type init.
	KybStatusInit KybStatus = "init"
	// KybStatusPendingReview is a KybStatus of type pending_review.
	KybStatusPendingReview KybStatus = "pending_review"
	// KybStatusUnderReview is a KybStatus of type under_review.
	KybStatusUnderReview KybStatus = "under_review"
	// KybStatusPendingResponse is a KybStatus of type pending_response.
	KybStatusPendingResponse KybStatus = "pending_response"
	// KybStatusEscalated is a KybStatus of type escalated.
	KybStatusEscalated KybStatus = "escalated"
	// KybStatusPendingApproval is a KybStatus of type pending_approval.
	KybStatusPendingApproval KybStatus = "pending_approval"
	// KybStatusRejected is a KybStatus of type rejected.
	KybStatusRejected KybStatus = "rejected"
	// KybStatusApproved is a KybStatus of type approved.
	KybStatusApproved KybStatus = "approved"
)

var ErrInvalidKybStatus = fmt.Errorf("not a valid KybStatus, try [%s]", strings.Join(_KybStatusNames, ", "))

var _KybStatusNames = []string{
	string(KybStatusInit),
	string(KybStatusPendingReview),
	string(KybStatusUnderReview),
	string(KybStatusPendingResponse),
	string(KybStatusEscalated),
	string(KybStatusPendingApproval),
	string(KybStatusRejected),
	string(KybStatusApproved),
}

// KybStatusNames returns a list of possible string values of KybStatus.
func KybStatusNames() []string {
	tmp := make([]string, len(_KybStatusNames))
	copy(tmp, _KybStatusNames)
	return tmp
}

// String implements the Stringer interface.
func (x KybStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x KybStatus) IsValid() bool {
	_, err := ParseKybStatus(string(x))
	return err == nil
}

var _KybStatusValue = map[string]KybStatus{
	"init":             KybStatusInit,
	"pending_review":   KybStatusPendingReview,
	"under_review":     KybStatusUnderReview,
	"pending_response": KybStatusPendingResponse,
	"escalated":        KybStatusEscalated,
	"pending_approval": KybStatusPendingApproval,
	"rejected":         KybStatusRejected,
	"approved":         KybStatusApproved,
}

// ParseKybStatus attempts to convert a string to a KybStatus.
func ParseKybStatus(name string) (KybStatus, error) {
	if x, ok := _KybStatusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _KybStatusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return KybStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidKybStatus)
}

// MarshalText implements the text marshaller method.
func (x KybStatus) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *KybStatus) UnmarshalText(text []byte) error {
	tmp, err := ParseKybStatus(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *KybStatus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MoneyRange099999 is a MoneyRange of type 0_99999.
	MoneyRange099999 MoneyRange = "0_99999"
	// MoneyRange100000499999 is a MoneyRange of type 100000_499999.
	MoneyRange100000499999 MoneyRange = "100000_499999"
	// MoneyRange500000999999 is a MoneyRange of type 500000_999999.
	MoneyRange500000999999 MoneyRange = "500000_999999"
	// MoneyRange10000004999999 is a MoneyRange of type 1000000_4999999.
	MoneyRange10000004999999 MoneyRange = "1000000_4999999"
	// MoneyRange5000000Plus is a MoneyRange of type 5000000_plus.
	MoneyRange5000000Plus MoneyRange = "5000000_plus"
)

var ErrInvalidMoneyRange = fmt.Errorf("not a valid MoneyRange, try [%s]", strings.Join(_MoneyRangeNames, ", "))

var _MoneyRangeNames = []string{
	string(MoneyRange099999),
	string(MoneyRange100000499999),
	string(MoneyRange500000999999),
	string(MoneyRange10000004999999),
	string(MoneyRange5000000Plus),
}

// MoneyRangeNames returns a list of possible string values of MoneyRange.
func MoneyRangeNames() []string {
	tmp := make([]string, len(_MoneyRangeNames))
	copy(tmp, _MoneyRangeNames)
	return tmp
}

// String implements the Stringer interface.
func (x MoneyRange) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MoneyRange) IsValid() bool {
	_, err := ParseMoneyRange(string(x))
	return err == nil
}

var _MoneyRangeValue = map[string]MoneyRange{
	"0_99999":         MoneyRange099999,
	"100000_499999":   MoneyRange100000499999,
	"500000_999999":   MoneyRange500000999999,
	"1000000_4999999": MoneyRange10000004999999,
	"5000000_plus":    MoneyRange5000000Plus,
}

// ParseMoneyRange attempts to convert a string to a MoneyRange.
func ParseMoneyRange(name string) (MoneyRange, error) {
	if x, ok := _MoneyRangeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _MoneyRangeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return MoneyRange(""), fmt.Errorf("%s is %w", name, ErrInvalidMoneyRange)
}

// MarshalText implements the text marshaller method.
func (x MoneyRange) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MoneyRange) UnmarshalText(text []byte) error {
	tmp, err := ParseMoneyRange(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *MoneyRange) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfFundsBusinessLoans is a SourceOfFunds of type business_loans.
	SourceOfFundsBusinessLoans SourceOfFunds = "business_loans"
	// SourceOfFundsGrants is a SourceOfFunds of type grants.
	SourceOfFundsGrants SourceOfFunds = "grants"
	// SourceOfFundsInterCompanyFunds is a SourceOfFunds of type inter_company_funds.
	SourceOfFundsInterCompanyFunds SourceOfFunds = "inter_company_funds"
	// SourceOfFundsInvestmentProceeds is a SourceOfFunds of type investment_proceeds.
	SourceOfFundsInvestmentProceeds SourceOfFunds = "investment_proceeds"
	// SourceOfFundsLegalSettlement is a SourceOfFunds of type legal_settlement.
	SourceOfFundsLegalSettlement SourceOfFunds = "legal_settlement"
	// SourceOfFundsOwnersCapital is a SourceOfFunds of type owners_capital.
	SourceOfFundsOwnersCapital SourceOfFunds = "owners_capital"
	// SourceOfFundsPensionRetirement is a SourceOfFunds of type pension_retirement.
	SourceOfFundsPensionRetirement SourceOfFunds = "pension_retirement"
	// SourceOfFundsSaleOfAssets is a SourceOfFunds of type sale_of_assets.
	SourceOfFundsSaleOfAssets SourceOfFunds = "sale_of_assets"
	// SourceOfFundsSalesOfGoodsAndServices is a SourceOfFunds of type sales_of_goods_and_services.
	SourceOfFundsSalesOfGoodsAndServices SourceOfFunds = "sales_of_goods_and_services"
	// SourceOfFundsTaxRefund is a SourceOfFunds of type tax_refund.
	SourceOfFundsTaxRefund SourceOfFunds = "tax_refund"
	// SourceOfFundsThirdPartyFunds is a SourceOfFunds of type third_party_funds.
	SourceOfFundsThirdPartyFunds SourceOfFunds = "third_party_funds"
	// SourceOfFundsTreasuryReserves is a SourceOfFunds of type treasury_reserves.
	SourceOfFundsTreasuryReserves SourceOfFunds = "treasury_reserves"
)

var ErrInvalidSourceOfFunds = fmt.Errorf("not a valid SourceOfFunds, try [%s]", strings.Join(_SourceOfFundsNames, ", "))

var _SourceOfFundsNames = []string{
	string(SourceOfFundsBusinessLoans),
	string(SourceOfFundsGrants),
	string(SourceOfFundsInterCompanyFunds),
	string(SourceOfFundsInvestmentProceeds),
	string(SourceOfFundsLegalSettlement),
	string(SourceOfFundsOwnersCapital),
	string(SourceOfFundsPensionRetirement),
	string(SourceOfFundsSaleOfAssets),
	string(SourceOfFundsSalesOfGoodsAndServices),
	string(SourceOfFundsTaxRefund),
	string(SourceOfFundsThirdPartyFunds),
	string(SourceOfFundsTreasuryReserves),
}

// SourceOfFundsNames returns a list of possible string values of SourceOfFunds.
func SourceOfFundsNames() []string {
	tmp := make([]string, len(_SourceOfFundsNames))
	copy(tmp, _SourceOfFundsNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfFunds) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfFunds) IsValid() bool {
	_, err := ParseSourceOfFunds(string(x))
	return err == nil
}

var _SourceOfFundsValue = map[string]SourceOfFunds{
	"business_loans":              SourceOfFundsBusinessLoans,
	"grants":                      SourceOfFundsGrants,
	"inter_company_funds":         SourceOfFundsInterCompanyFunds,
	"investment_proceeds":         SourceOfFundsInvestmentProceeds,
	"legal_settlement":            SourceOfFundsLegalSettlement,
	"owners_capital":              SourceOfFundsOwnersCapital,
	"pension_retirement":          SourceOfFundsPensionRetirement,
	"sale_of_assets":              SourceOfFundsSaleOfAssets,
	"sales_of_goods_and_services": SourceOfFundsSalesOfGoodsAndServices,
	"tax_refund":                  SourceOfFundsTaxRefund,
	"third_party_funds":           SourceOfFundsThirdPartyFunds,
	"treasury_reserves":           SourceOfFundsTreasuryReserves,
}

// ParseSourceOfFunds attempts to convert a string to a SourceOfFunds.
func ParseSourceOfFunds(name string) (SourceOfFunds, error) {
	if x, ok := _SourceOfFundsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfFundsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfFunds(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfFunds)
}

// MarshalText implements the text marshaller method.
func (x SourceOfFunds) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfFunds) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfFunds(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfFunds) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfWealthBusinessDividendsOrProfits is a SourceOfWealth of type business_dividends_or_profits.
	SourceOfWealthBusinessDividendsOrProfits SourceOfWealth = "business_dividends_or_profits"
	// SourceOfWealthSaleOfBusiness is a SourceOfWealth of type sale_of_business.
	SourceOfWealthSaleOfBusiness SourceOfWealth = "sale_of_business"
	// SourceOfWealthInheritance is a SourceOfWealth of type inheritance.
	SourceOfWealthInheritance SourceOfWealth = "inheritance"
	// SourceOfWealthRealEstateInvestments is a SourceOfWealth of type real_estate_investments.
	SourceOfWealthRealEstateInvestments SourceOfWealth = "real_estate_investments"
	// SourceOfWealthInvestmentReturns is a SourceOfWealth of type investment_returns.
	SourceOfWealthInvestmentReturns SourceOfWealth = "investment_returns"
	// SourceOfWealthAccumulatedRevenue is a SourceOfWealth of type accumulated_revenue.
	SourceOfWealthAccumulatedRevenue SourceOfWealth = "accumulated_revenue"
	// SourceOfWealthOther is a SourceOfWealth of type other.
	SourceOfWealthOther SourceOfWealth = "other"
)

var ErrInvalidSourceOfWealth = fmt.Errorf("not a valid SourceOfWealth, try [%s]", strings.Join(_SourceOfWealthNames, ", "))

var _SourceOfWealthNames = []string{
	string(SourceOfWealthBusinessDividendsOrProfits),
	string(SourceOfWealthSaleOfBusiness),
	string(SourceOfWealthInheritance),
	string(SourceOfWealthRealEstateInvestments),
	string(SourceOfWealthInvestmentReturns),
	string(SourceOfWealthAccumulatedRevenue),
	string(SourceOfWealthOther),
}

// SourceOfWealthNames returns a list of possible string values of SourceOfWealth.
func SourceOfWealthNames() []string {
	tmp := make([]string, len(_SourceOfWealthNames))
	copy(tmp, _SourceOfWealthNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfWealth) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfWealth) IsValid() bool {
	_, err := ParseSourceOfWealth(string(x))
	return err == nil
}

var _SourceOfWealthValue = map[string]SourceOfWealth{
	"business_dividends_or_profits": SourceOfWealthBusinessDividendsOrProfits,
	"sale_of_business":              SourceOfWealthSaleOfBusiness,
	"inheritance":                   SourceOfWealthInheritance,
	"real_estate_investments":       SourceOfWealthRealEstateInvestments,
	"investment_returns":            SourceOfWealthInvestmentReturns,
	"accumulated_revenue":           SourceOfWealthAccumulatedRevenue,
	"other":                         SourceOfWealthOther,
}

// ParseSourceOfWealth attempts to convert a string to a SourceOfWealth.
func ParseSourceOfWealth(name string) (SourceOfWealth, error) {
	if x, ok := _SourceOfWealthValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfWealthValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfWealth(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfWealth)
}

// MarshalText implements the text marshaller method.
func (x SourceOfWealth) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfWealth) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfWealth(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfWealth) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TaxIDTypeSSN is a TaxIDType of type SSN.
	TaxIDTypeSSN TaxIDType = "SSN"
	// TaxIDTypeEIN is a TaxIDType of type EIN.
	TaxIDTypeEIN TaxIDType = "EIN"
	// TaxIDTypeTFN is a TaxIDType of type TFN.
	TaxIDTypeTFN TaxIDType = "TFN"
	// TaxIDTypeABN is a TaxIDType of type ABN.
	TaxIDTypeABN TaxIDType = "ABN"
	// TaxIDTypeACN is a TaxIDType of type ACN.
	TaxIDTypeACN TaxIDType = "ACN"
	// TaxIDTypeUTR is a TaxIDType of type UTR.
	TaxIDTypeUTR TaxIDType = "UTR"
	// TaxIDTypeNINO is a TaxIDType of type NINO.
	TaxIDTypeNINO TaxIDType = "NINO"
	// TaxIDTypeNRIC is a TaxIDType of type NRIC.
	TaxIDTypeNRIC TaxIDType = "NRIC"
	// TaxIDTypeFIN is a TaxIDType of type FIN.
	TaxIDTypeFIN TaxIDType = "FIN"
	// TaxIDTypeASDG is a TaxIDType of type ASDG.
	TaxIDTypeASDG TaxIDType = "ASDG"
	// TaxIDTypeITR is a TaxIDType of type ITR.
	TaxIDTypeITR TaxIDType = "ITR"
	// TaxIDTypeNIF is a TaxIDType of type NIF.
	TaxIDTypeNIF TaxIDType = "NIF"
	// TaxIDTypeTIN is a TaxIDType of type TIN.
	TaxIDTypeTIN TaxIDType = "TIN"
	// TaxIDTypeVAT is a TaxIDType of type VAT.
	TaxIDTypeVAT TaxIDType = "VAT"
	// TaxIDTypeCUIL is a TaxIDType of type CUIL.
	TaxIDTypeCUIL TaxIDType = "CUIL"
	// TaxIDTypeCUIT is a TaxIDType of type CUIT.
	TaxIDTypeCUIT TaxIDType = "CUIT"
	// TaxIDTypeDNI is a TaxIDType of type DNI.
	TaxIDTypeDNI TaxIDType = "DNI"
	// TaxIDTypeBIN is a TaxIDType of type BIN.
	TaxIDTypeBIN TaxIDType = "BIN"
	// TaxIDTypeUNP is a TaxIDType of type UNP.
	TaxIDTypeUNP TaxIDType = "UNP"
	// TaxIDTypeRNPM is a TaxIDType of type RNPM.
	TaxIDTypeRNPM TaxIDType = "RNPM"
	// TaxIDTypeNIT is a TaxIDType of type NIT.
	TaxIDTypeNIT TaxIDType = "NIT"
	// TaxIDTypeCPF is a TaxIDType of type CPF.
	TaxIDTypeCPF TaxIDType = "CPF"
	// TaxIDTypeCNPJ is a TaxIDType of type CNPJ.
	TaxIDTypeCNPJ TaxIDType = "CNPJ"
	// TaxIDTypeNIRE is a TaxIDType of type NIRE.
	TaxIDTypeNIRE TaxIDType = "NIRE"
	// TaxIDTypeUCN is a TaxIDType of type UCN.
	TaxIDTypeUCN TaxIDType = "UCN"
	// TaxIDTypeUIC is a TaxIDType of type UIC.
	TaxIDTypeUIC TaxIDType = "UIC"
	// TaxIDTypeSIN is a TaxIDType of type SIN.
	TaxIDTypeSIN TaxIDType = "SIN"
	// TaxIDTypeBN is a TaxIDType of type BN.
	TaxIDTypeBN TaxIDType = "BN"
	// TaxIDTypeRUT is a TaxIDType of type RUT.
	TaxIDTypeRUT TaxIDType = "RUT"
	// TaxIDTypeIIN is a TaxIDType of type IIN.
	TaxIDTypeIIN TaxIDType = "IIN"
	// TaxIDTypeUSCC is a TaxIDType of type USCC.
	TaxIDTypeUSCC TaxIDType = "USCC"
	// TaxIDTypeCNOC is a TaxIDType of type CNOC.
	TaxIDTypeCNOC TaxIDType = "CNOC"
	// TaxIDTypeUSCN is a TaxIDType of type USCN.
	TaxIDTypeUSCN TaxIDType = "USCN"
	// TaxIDTypeITIN is a TaxIDType of type ITIN.
	TaxIDTypeITIN TaxIDType = "ITIN"
	// TaxIDTypeCPJ is a TaxIDType of type CPJ.
	TaxIDTypeCPJ TaxIDType = "CPJ"
	// TaxIDTypeOIB is a TaxIDType of type OIB.
	TaxIDTypeOIB TaxIDType = "OIB"
	// TaxIDTypeDIC is a TaxIDType of type DIC.
	TaxIDTypeDIC TaxIDType = "DIC"
	// TaxIDTypeCPR is a TaxIDType of type CPR.
	TaxIDTypeCPR TaxIDType = "CPR"
	// TaxIDTypeCVR is a TaxIDType of type CVR.
	TaxIDTypeCVR TaxIDType = "CVR"
	// TaxIDTypeCN is a TaxIDType of type CN.
	TaxIDTypeCN TaxIDType = "CN"
	// TaxIDTypeRNC is a TaxIDType of type RNC.
	TaxIDTypeRNC TaxIDType = "RNC"
	// TaxIDTypeRUC is a TaxIDType of type RUC.
	TaxIDTypeRUC TaxIDType = "RUC"
	// TaxIDTypeTN is a TaxIDType of type TN.
	TaxIDTypeTN TaxIDType = "TN"
	// TaxIDTypeHETU is a TaxIDType of type HETU.
	TaxIDTypeHETU TaxIDType = "HETU"
	// TaxIDTypeYT is a TaxIDType of type YT.
	TaxIDTypeYT TaxIDType = "YT"
	// TaxIDTypeALV is a TaxIDType of type ALV.
	TaxIDTypeALV TaxIDType = "ALV"
	// TaxIDTypeSIREN is a TaxIDType of type SIREN.
	TaxIDTypeSIREN TaxIDType = "SIREN"
	// TaxIDTypeIDNR is a TaxIDType of type IDNR.
	TaxIDTypeIDNR TaxIDType = "IDNR"
	// TaxIDTypeSTNR is a TaxIDType of type STNR.
	TaxIDTypeSTNR TaxIDType = "STNR"
	// TaxIDTypeVTA is a TaxIDType of type VTA.
	TaxIDTypeVTA TaxIDType = "VTA"
	// TaxIDTypeHKID is a TaxIDType of type HKID.
	TaxIDTypeHKID TaxIDType = "HKID"
	// TaxIDTypeAJ is a TaxIDType of type AJ.
	TaxIDTypeAJ TaxIDType = "AJ"
	// TaxIDTypeEN is a TaxIDType of type EN.
	TaxIDTypeEN TaxIDType = "EN"
	// TaxIDTypeKN is a TaxIDType of type KN.
	TaxIDTypeKN TaxIDType = "KN"
	// TaxIDTypeVSK is a TaxIDType of type VSK.
	TaxIDTypeVSK TaxIDType = "VSK"
	// TaxIDTypePAN is a TaxIDType of type PAN.
	TaxIDTypePAN TaxIDType = "PAN"
	// TaxIDTypeGSTN is a TaxIDType of type GSTN.
	TaxIDTypeGSTN TaxIDType = "GSTN"
	// TaxIDTypeNIK is a TaxIDType of type NIK.
	TaxIDTypeNIK TaxIDType = "NIK"
	// TaxIDTypeNPWP is a TaxIDType of type NPWP.
	TaxIDTypeNPWP TaxIDType = "NPWP"
	// TaxIDTypePPS is a TaxIDType of type PPS.
	TaxIDTypePPS TaxIDType = "PPS"
	// TaxIDTypeTRN is a TaxIDType of type TRN.
	TaxIDTypeTRN TaxIDType = "TRN"
	// TaxIDTypeCRO is a TaxIDType of type CRO.
	TaxIDTypeCRO TaxIDType = "CRO"
	// TaxIDTypeCHY is a TaxIDType of type CHY.
	TaxIDTypeCHY TaxIDType = "CHY"
	// TaxIDTypeCF is a TaxIDType of type CF.
	TaxIDTypeCF TaxIDType = "CF"
	// TaxIDTypeIVA is a TaxIDType of type IVA.
	TaxIDTypeIVA TaxIDType = "IVA"
	// TaxIDTypeIN is a TaxIDType of type IN.
	TaxIDTypeIN TaxIDType = "IN"
	// TaxIDTypeJCT is a TaxIDType of type JCT.
	TaxIDTypeJCT TaxIDType = "JCT"
	// TaxIDTypeEDRPOU is a TaxIDType of type EDRPOU.
	TaxIDTypeEDRPOU TaxIDType = "EDRPOU"
	// TaxIDTypeEID is a TaxIDType of type EID.
	TaxIDTypeEID TaxIDType = "EID"
)

var ErrInvalidTaxIDType = fmt.Errorf("not a valid TaxIDType, try [%s]", strings.Join(_TaxIDTypeNames, ", "))

var _TaxIDTypeNames = []string{
	string(TaxIDTypeSSN),
	string(TaxIDTypeEIN),
	string(TaxIDTypeTFN),
	string(TaxIDTypeABN),
	string(TaxIDTypeACN),
	string(TaxIDTypeUTR),
	string(TaxIDTypeNINO),
	string(TaxIDTypeNRIC),
	string(TaxIDTypeFIN),
	string(TaxIDTypeASDG),
	string(TaxIDTypeITR),
	string(TaxIDTypeNIF),
	string(TaxIDTypeTIN),
	string(TaxIDTypeVAT),
	string(TaxIDTypeCUIL),
	string(TaxIDTypeCUIT),
	string(TaxIDTypeDNI),
	string(TaxIDTypeBIN),
	string(TaxIDTypeUNP),
	string(TaxIDTypeRNPM),
	string(TaxIDTypeNIT),
	string(TaxIDTypeCPF),
	string(TaxIDTypeCNPJ),
	string(TaxIDTypeNIRE),
	string(TaxIDTypeUCN),
	string(TaxIDTypeUIC),
	string(TaxIDTypeSIN),
	string(TaxIDTypeBN),
	string(TaxIDTypeRUT),
	string(TaxIDTypeIIN),
	string(TaxIDTypeUSCC),
	string(TaxIDTypeCNOC),
	string(TaxIDTypeUSCN),
	string(TaxIDTypeITIN),
	string(TaxIDTypeCPJ),
	string(TaxIDTypeOIB),
	string(TaxIDTypeDIC),
	string(TaxIDTypeCPR),
	string(TaxIDTypeCVR),
	string(TaxIDTypeCN),
	string(TaxIDTypeRNC),
	string(TaxIDTypeRUC),
	string(TaxIDTypeTN),
	string(TaxIDTypeHETU),
	string(TaxIDTypeYT),
	string(TaxIDTypeALV),
	string(TaxIDTypeSIREN),
	string(TaxIDTypeIDNR),
	string(TaxIDTypeSTNR),
	string(TaxIDTypeVTA),
	string(TaxIDTypeHKID),
	string(TaxIDTypeAJ),
	string(TaxIDTypeEN),
	string(TaxIDTypeKN),
	string(TaxIDTypeVSK),
	string(TaxIDTypePAN),
	string(TaxIDTypeGSTN),
	string(TaxIDTypeNIK),
	string(TaxIDTypeNPWP),
	string(TaxIDTypePPS),
	string(TaxIDTypeTRN),
	string(TaxIDTypeCRO),
	string(TaxIDTypeCHY),
	string(TaxIDTypeCF),
	string(TaxIDTypeIVA),
	string(TaxIDTypeIN),
	string(TaxIDTypeJCT),
	string(TaxIDTypeEDRPOU),
	string(TaxIDTypeEID),
}

// TaxIDTypeNames returns a list of possible string values of TaxIDType.
func TaxIDTypeNames() []string {
	tmp := make([]string, len(_TaxIDTypeNames))
	copy(tmp, _TaxIDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x TaxIDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TaxIDType) IsValid() bool {
	_, err := ParseTaxIDType(string(x))
	return err == nil
}

var _TaxIDTypeValue = map[string]TaxIDType{
	"SSN":    TaxIDTypeSSN,
	"ssn":    TaxIDTypeSSN,
	"EIN":    TaxIDTypeEIN,
	"ein":    TaxIDTypeEIN,
	"TFN":    TaxIDTypeTFN,
	"tfn":    TaxIDTypeTFN,
	"ABN":    TaxIDTypeABN,
	"abn":    TaxIDTypeABN,
	"ACN":    TaxIDTypeACN,
	"acn":    TaxIDTypeACN,
	"UTR":    TaxIDTypeUTR,
	"utr":    TaxIDTypeUTR,
	"NINO":   TaxIDTypeNINO,
	"nino":   TaxIDTypeNINO,
	"NRIC":   TaxIDTypeNRIC,
	"nric":   TaxIDTypeNRIC,
	"FIN":    TaxIDTypeFIN,
	"fin":    TaxIDTypeFIN,
	"ASDG":   TaxIDTypeASDG,
	"asdg":   TaxIDTypeASDG,
	"ITR":    TaxIDTypeITR,
	"itr":    TaxIDTypeITR,
	"NIF":    TaxIDTypeNIF,
	"nif":    TaxIDTypeNIF,
	"TIN":    TaxIDTypeTIN,
	"tin":    TaxIDTypeTIN,
	"VAT":    TaxIDTypeVAT,
	"vat":    TaxIDTypeVAT,
	"CUIL":   TaxIDTypeCUIL,
	"cuil":   TaxIDTypeCUIL,
	"CUIT":   TaxIDTypeCUIT,
	"cuit":   TaxIDTypeCUIT,
	"DNI":    TaxIDTypeDNI,
	"dni":    TaxIDTypeDNI,
	"BIN":    TaxIDTypeBIN,
	"bin":    TaxIDTypeBIN,
	"UNP":    TaxIDTypeUNP,
	"unp":    TaxIDTypeUNP,
	"RNPM":   TaxIDTypeRNPM,
	"rnpm":   TaxIDTypeRNPM,
	"NIT":    TaxIDTypeNIT,
	"nit":    TaxIDTypeNIT,
	"CPF":    TaxIDTypeCPF,
	"cpf":    TaxIDTypeCPF,
	"CNPJ":   TaxIDTypeCNPJ,
	"cnpj":   TaxIDTypeCNPJ,
	"NIRE":   TaxIDTypeNIRE,
	"nire":   TaxIDTypeNIRE,
	"UCN":    TaxIDTypeUCN,
	"ucn":    TaxIDTypeUCN,
	"UIC":    TaxIDTypeUIC,
	"uic":    TaxIDTypeUIC,
	"SIN":    TaxIDTypeSIN,
	"sin":    TaxIDTypeSIN,
	"BN":     TaxIDTypeBN,
	"bn":     TaxIDTypeBN,
	"RUT":    TaxIDTypeRUT,
	"rut":    TaxIDTypeRUT,
	"IIN":    TaxIDTypeIIN,
	"iin":    TaxIDTypeIIN,
	"USCC":   TaxIDTypeUSCC,
	"uscc":   TaxIDTypeUSCC,
	"CNOC":   TaxIDTypeCNOC,
	"cnoc":   TaxIDTypeCNOC,
	"USCN":   TaxIDTypeUSCN,
	"uscn":   TaxIDTypeUSCN,
	"ITIN":   TaxIDTypeITIN,
	"itin":   TaxIDTypeITIN,
	"CPJ":    TaxIDTypeCPJ,
	"cpj":    TaxIDTypeCPJ,
	"OIB":    TaxIDTypeOIB,
	"oib":    TaxIDTypeOIB,
	"DIC":    TaxIDTypeDIC,
	"dic":    TaxIDTypeDIC,
	"CPR":    TaxIDTypeCPR,
	"cpr":    TaxIDTypeCPR,
	"CVR":    TaxIDTypeCVR,
	"cvr":    TaxIDTypeCVR,
	"CN":     TaxIDTypeCN,
	"cn":     TaxIDTypeCN,
	"RNC":    TaxIDTypeRNC,
	"rnc":    TaxIDTypeRNC,
	"RUC":    TaxIDTypeRUC,
	"ruc":    TaxIDTypeRUC,
	"TN":     TaxIDTypeTN,
	"tn":     TaxIDTypeTN,
	"HETU":   TaxIDTypeHETU,
	"hetu":   TaxIDTypeHETU,
	"YT":     TaxIDTypeYT,
	"yt":     TaxIDTypeYT,
	"ALV":    TaxIDTypeALV,
	"alv":    TaxIDTypeALV,
	"SIREN":  TaxIDTypeSIREN,
	"siren":  TaxIDTypeSIREN,
	"IDNR":   TaxIDTypeIDNR,
	"idnr":   TaxIDTypeIDNR,
	"STNR":   TaxIDTypeSTNR,
	"stnr":   TaxIDTypeSTNR,
	"VTA":    TaxIDTypeVTA,
	"vta":    TaxIDTypeVTA,
	"HKID":   TaxIDTypeHKID,
	"hkid":   TaxIDTypeHKID,
	"AJ":     TaxIDTypeAJ,
	"aj":     TaxIDTypeAJ,
	"EN":     TaxIDTypeEN,
	"en":     TaxIDTypeEN,
	"KN":     TaxIDTypeKN,
	"kn":     TaxIDTypeKN,
	"VSK":    TaxIDTypeVSK,
	"vsk":    TaxIDTypeVSK,
	"PAN":    TaxIDTypePAN,
	"pan":    TaxIDTypePAN,
	"GSTN":   TaxIDTypeGSTN,
	"gstn":   TaxIDTypeGSTN,
	"NIK":    TaxIDTypeNIK,
	"nik":    TaxIDTypeNIK,
	"NPWP":   TaxIDTypeNPWP,
	"npwp":   TaxIDTypeNPWP,
	"PPS":    TaxIDTypePPS,
	"pps":    TaxIDTypePPS,
	"TRN":    TaxIDTypeTRN,
	"trn":    TaxIDTypeTRN,
	"CRO":    TaxIDTypeCRO,
	"cro":    TaxIDTypeCRO,
	"CHY":    TaxIDTypeCHY,
	"chy":    TaxIDTypeCHY,
	"CF":     TaxIDTypeCF,
	"cf":     TaxIDTypeCF,
	"IVA":    TaxIDTypeIVA,
	"iva":    TaxIDTypeIVA,
	"IN":     TaxIDTypeIN,
	"in":     TaxIDTypeIN,
	"JCT":    TaxIDTypeJCT,
	"jct":    TaxIDTypeJCT,
	"EDRPOU": TaxIDTypeEDRPOU,
	"edrpou": TaxIDTypeEDRPOU,
	"EID":    TaxIDTypeEID,
	"eid":    TaxIDTypeEID,
}

// ParseTaxIDType attempts to convert a string to a TaxIDType.
func ParseTaxIDType(name string) (TaxIDType, error) {
	if x, ok := _TaxIDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TaxIDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TaxIDType(""), fmt.Errorf("%s is %w", name, ErrInvalidTaxIDType)
}

// MarshalText implements the text marshaller method.
func (x TaxIDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TaxIDType) UnmarshalText(text []byte) error {
	tmp, err := ParseTaxIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TaxIDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
