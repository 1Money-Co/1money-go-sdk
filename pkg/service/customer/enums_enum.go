// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package customer

import (
	"fmt"
	"strings"
)

const (
	// AccountPurposeCharitableDonations is a AccountPurpose of type charitable_donations.
	AccountPurposeCharitableDonations AccountPurpose = "charitable_donations"
	// AccountPurposeEcommerceRetailPayments is a AccountPurpose of type ecommerce_retail_payments.
	AccountPurposeEcommerceRetailPayments AccountPurpose = "ecommerce_retail_payments"
	// AccountPurposeInvestmentPurposes is a AccountPurpose of type investment_purposes.
	AccountPurposeInvestmentPurposes AccountPurpose = "investment_purposes"
	// AccountPurposeOther is a AccountPurpose of type other.
	AccountPurposeOther AccountPurpose = "other"
	// AccountPurposePaymentsToFriendsOrFamilyAbroad is a AccountPurpose of type payments_to_friends_or_family_abroad.
	AccountPurposePaymentsToFriendsOrFamilyAbroad AccountPurpose = "payments_to_friends_or_family_abroad"
	// AccountPurposePayroll is a AccountPurpose of type payroll.
	AccountPurposePayroll AccountPurpose = "payroll"
	// AccountPurposePersonalOrLivingExpenses is a AccountPurpose of type personal_or_living_expenses.
	AccountPurposePersonalOrLivingExpenses AccountPurpose = "personal_or_living_expenses"
	// AccountPurposeProtectWealth is a AccountPurpose of type protect_wealth.
	AccountPurposeProtectWealth AccountPurpose = "protect_wealth"
	// AccountPurposePurchaseGoodsAndServices is a AccountPurpose of type purchase_goods_and_services.
	AccountPurposePurchaseGoodsAndServices AccountPurpose = "purchase_goods_and_services"
	// AccountPurposeReceivePaymentsForGoodsAndServices is a AccountPurpose of type receive_payments_for_goods_and_services.
	AccountPurposeReceivePaymentsForGoodsAndServices AccountPurpose = "receive_payments_for_goods_and_services"
	// AccountPurposeTaxOptimization is a AccountPurpose of type tax_optimization.
	AccountPurposeTaxOptimization AccountPurpose = "tax_optimization"
	// AccountPurposeThirdPartyMoneyTransmission is a AccountPurpose of type third_party_money_transmission.
	AccountPurposeThirdPartyMoneyTransmission AccountPurpose = "third_party_money_transmission"
	// AccountPurposeTreasuryManagement is a AccountPurpose of type treasury_management.
	AccountPurposeTreasuryManagement AccountPurpose = "treasury_management"
)

var ErrInvalidAccountPurpose = fmt.Errorf("not a valid AccountPurpose, try [%s]", strings.Join(_AccountPurposeNames, ", "))

var _AccountPurposeNames = []string{
	string(AccountPurposeCharitableDonations),
	string(AccountPurposeEcommerceRetailPayments),
	string(AccountPurposeInvestmentPurposes),
	string(AccountPurposeOther),
	string(AccountPurposePaymentsToFriendsOrFamilyAbroad),
	string(AccountPurposePayroll),
	string(AccountPurposePersonalOrLivingExpenses),
	string(AccountPurposeProtectWealth),
	string(AccountPurposePurchaseGoodsAndServices),
	string(AccountPurposeReceivePaymentsForGoodsAndServices),
	string(AccountPurposeTaxOptimization),
	string(AccountPurposeThirdPartyMoneyTransmission),
	string(AccountPurposeTreasuryManagement),
}

// AccountPurposeNames returns a list of possible string values of AccountPurpose.
func AccountPurposeNames() []string {
	tmp := make([]string, len(_AccountPurposeNames))
	copy(tmp, _AccountPurposeNames)
	return tmp
}

// String implements the Stringer interface.
func (x AccountPurpose) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AccountPurpose) IsValid() bool {
	_, err := ParseAccountPurpose(string(x))
	return err == nil
}

var _AccountPurposeValue = map[string]AccountPurpose{
	"charitable_donations":                    AccountPurposeCharitableDonations,
	"ecommerce_retail_payments":               AccountPurposeEcommerceRetailPayments,
	"investment_purposes":                     AccountPurposeInvestmentPurposes,
	"other":                                   AccountPurposeOther,
	"payments_to_friends_or_family_abroad":    AccountPurposePaymentsToFriendsOrFamilyAbroad,
	"payroll":                                 AccountPurposePayroll,
	"personal_or_living_expenses":             AccountPurposePersonalOrLivingExpenses,
	"protect_wealth":                          AccountPurposeProtectWealth,
	"purchase_goods_and_services":             AccountPurposePurchaseGoodsAndServices,
	"receive_payments_for_goods_and_services": AccountPurposeReceivePaymentsForGoodsAndServices,
	"tax_optimization":                        AccountPurposeTaxOptimization,
	"third_party_money_transmission":          AccountPurposeThirdPartyMoneyTransmission,
	"treasury_management":                     AccountPurposeTreasuryManagement,
}

// ParseAccountPurpose attempts to convert a string to a AccountPurpose.
func ParseAccountPurpose(name string) (AccountPurpose, error) {
	if x, ok := _AccountPurposeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AccountPurposeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AccountPurpose(""), fmt.Errorf("%s is %w", name, ErrInvalidAccountPurpose)
}

// MarshalText implements the text marshaller method.
func (x AccountPurpose) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AccountPurpose) UnmarshalText(text []byte) error {
	tmp, err := ParseAccountPurpose(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AccountPurpose) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution is a BusinessIndustry of type bank_credit_unions_regulated_financial_institution.
	BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution BusinessIndustry = "bank_credit_unions_regulated_financial_institution"
	// BusinessIndustryProfessionalServices is a BusinessIndustry of type professional_services.
	BusinessIndustryProfessionalServices BusinessIndustry = "professional_services"
	// BusinessIndustryTechnologyECommercePlatforms is a BusinessIndustry of type technology_e_commerce_platforms.
	BusinessIndustryTechnologyECommercePlatforms BusinessIndustry = "technology_e_commerce_platforms"
	// BusinessIndustryGeneralManufacturing is a BusinessIndustry of type general_manufacturing.
	BusinessIndustryGeneralManufacturing BusinessIndustry = "general_manufacturing"
	// BusinessIndustryGeneralWholesalers is a BusinessIndustry of type general_wholesalers.
	BusinessIndustryGeneralWholesalers BusinessIndustry = "general_wholesalers"
	// BusinessIndustryHealthcareAndSocialAssistance is a BusinessIndustry of type healthcare_and_social_assistance.
	BusinessIndustryHealthcareAndSocialAssistance BusinessIndustry = "healthcare_and_social_assistance"
	// BusinessIndustryEducationalServices is a BusinessIndustry of type educational_services.
	BusinessIndustryEducationalServices BusinessIndustry = "educational_services"
	// BusinessIndustryScientificAndTechnicalServices is a BusinessIndustry of type scientific_and_technical_services.
	BusinessIndustryScientificAndTechnicalServices BusinessIndustry = "scientific_and_technical_services"
	// BusinessIndustryNonBankFinancialInstitution is a BusinessIndustry of type non_bank_financial_institution.
	BusinessIndustryNonBankFinancialInstitution BusinessIndustry = "non_bank_financial_institution"
	// BusinessIndustryInvestmentFund is a BusinessIndustry of type investment_fund.
	BusinessIndustryInvestmentFund BusinessIndustry = "investment_fund"
	// BusinessIndustryRealEstate is a BusinessIndustry of type real_estate.
	BusinessIndustryRealEstate BusinessIndustry = "real_estate"
	// BusinessIndustryRetailTrade is a BusinessIndustry of type retail_trade.
	BusinessIndustryRetailTrade BusinessIndustry = "retail_trade"
	// BusinessIndustryArtsEntertainmentRecreation is a BusinessIndustry of type arts_entertainment_recreation.
	BusinessIndustryArtsEntertainmentRecreation BusinessIndustry = "arts_entertainment_recreation"
	// BusinessIndustryAccommodationFoodServices is a BusinessIndustry of type accommodation_food_services.
	BusinessIndustryAccommodationFoodServices BusinessIndustry = "accommodation_food_services"
	// BusinessIndustryOther is a BusinessIndustry of type other.
	BusinessIndustryOther BusinessIndustry = "other"
)

var ErrInvalidBusinessIndustry = fmt.Errorf("not a valid BusinessIndustry, try [%s]", strings.Join(_BusinessIndustryNames, ", "))

var _BusinessIndustryNames = []string{
	string(BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution),
	string(BusinessIndustryProfessionalServices),
	string(BusinessIndustryTechnologyECommercePlatforms),
	string(BusinessIndustryGeneralManufacturing),
	string(BusinessIndustryGeneralWholesalers),
	string(BusinessIndustryHealthcareAndSocialAssistance),
	string(BusinessIndustryEducationalServices),
	string(BusinessIndustryScientificAndTechnicalServices),
	string(BusinessIndustryNonBankFinancialInstitution),
	string(BusinessIndustryInvestmentFund),
	string(BusinessIndustryRealEstate),
	string(BusinessIndustryRetailTrade),
	string(BusinessIndustryArtsEntertainmentRecreation),
	string(BusinessIndustryAccommodationFoodServices),
	string(BusinessIndustryOther),
}

// BusinessIndustryNames returns a list of possible string values of BusinessIndustry.
func BusinessIndustryNames() []string {
	tmp := make([]string, len(_BusinessIndustryNames))
	copy(tmp, _BusinessIndustryNames)
	return tmp
}

// String implements the Stringer interface.
func (x BusinessIndustry) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BusinessIndustry) IsValid() bool {
	_, err := ParseBusinessIndustry(string(x))
	return err == nil
}

var _BusinessIndustryValue = map[string]BusinessIndustry{
	"bank_credit_unions_regulated_financial_institution": BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution,
	"professional_services":                              BusinessIndustryProfessionalServices,
	"technology_e_commerce_platforms":                    BusinessIndustryTechnologyECommercePlatforms,
	"general_manufacturing":                              BusinessIndustryGeneralManufacturing,
	"general_wholesalers":                                BusinessIndustryGeneralWholesalers,
	"healthcare_and_social_assistance":                   BusinessIndustryHealthcareAndSocialAssistance,
	"educational_services":                               BusinessIndustryEducationalServices,
	"scientific_and_technical_services":                  BusinessIndustryScientificAndTechnicalServices,
	"non_bank_financial_institution":                     BusinessIndustryNonBankFinancialInstitution,
	"investment_fund":                                    BusinessIndustryInvestmentFund,
	"real_estate":                                        BusinessIndustryRealEstate,
	"retail_trade":                                       BusinessIndustryRetailTrade,
	"arts_entertainment_recreation":                      BusinessIndustryArtsEntertainmentRecreation,
	"accommodation_food_services":                        BusinessIndustryAccommodationFoodServices,
	"other":                                              BusinessIndustryOther,
}

// ParseBusinessIndustry attempts to convert a string to a BusinessIndustry.
func ParseBusinessIndustry(name string) (BusinessIndustry, error) {
	if x, ok := _BusinessIndustryValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BusinessIndustryValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BusinessIndustry(""), fmt.Errorf("%s is %w", name, ErrInvalidBusinessIndustry)
}

// MarshalText implements the text marshaller method.
func (x BusinessIndustry) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BusinessIndustry) UnmarshalText(text []byte) error {
	tmp, err := ParseBusinessIndustry(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BusinessIndustry) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// BusinessTypeCooperative is a BusinessType of type cooperative.
	BusinessTypeCooperative BusinessType = "cooperative"
	// BusinessTypeCorporation is a BusinessType of type corporation.
	BusinessTypeCorporation BusinessType = "corporation"
	// BusinessTypeLlc is a BusinessType of type llc.
	BusinessTypeLlc BusinessType = "llc"
	// BusinessTypePartnership is a BusinessType of type partnership.
	BusinessTypePartnership BusinessType = "partnership"
	// BusinessTypeSoleProprietorship is a BusinessType of type sole_proprietorship.
	BusinessTypeSoleProprietorship BusinessType = "sole_proprietorship"
)

var ErrInvalidBusinessType = fmt.Errorf("not a valid BusinessType, try [%s]", strings.Join(_BusinessTypeNames, ", "))

var _BusinessTypeNames = []string{
	string(BusinessTypeCooperative),
	string(BusinessTypeCorporation),
	string(BusinessTypeLlc),
	string(BusinessTypePartnership),
	string(BusinessTypeSoleProprietorship),
}

// BusinessTypeNames returns a list of possible string values of BusinessType.
func BusinessTypeNames() []string {
	tmp := make([]string, len(_BusinessTypeNames))
	copy(tmp, _BusinessTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x BusinessType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BusinessType) IsValid() bool {
	_, err := ParseBusinessType(string(x))
	return err == nil
}

var _BusinessTypeValue = map[string]BusinessType{
	"cooperative":         BusinessTypeCooperative,
	"corporation":         BusinessTypeCorporation,
	"llc":                 BusinessTypeLlc,
	"partnership":         BusinessTypePartnership,
	"sole_proprietorship": BusinessTypeSoleProprietorship,
}

// ParseBusinessType attempts to convert a string to a BusinessType.
func ParseBusinessType(name string) (BusinessType, error) {
	if x, ok := _BusinessTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BusinessTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BusinessType(""), fmt.Errorf("%s is %w", name, ErrInvalidBusinessType)
}

// MarshalText implements the text marshaller method.
func (x BusinessType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BusinessType) UnmarshalText(text []byte) error {
	tmp, err := ParseBusinessType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BusinessType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// DocumentTypeCERTOFINC is a DocumentType of type CERT_OF_INC.
	DocumentTypeCERTOFINC DocumentType = "CERT_OF_INC"
	// DocumentTypeOPERATINGAGREEMENT is a DocumentType of type OPERATING_AGREEMENT.
	DocumentTypeOPERATINGAGREEMENT DocumentType = "OPERATING_AGREEMENT"
	// DocumentTypeBYLAWS is a DocumentType of type BYLAWS.
	DocumentTypeBYLAWS DocumentType = "BYLAWS"
	// DocumentTypePARTNERSHIPAGREEMENT is a DocumentType of type PARTNERSHIP_AGREEMENT.
	DocumentTypePARTNERSHIPAGREEMENT DocumentType = "PARTNERSHIP_AGREEMENT"
	// DocumentTypeBUSINESSLICENSE is a DocumentType of type BUSINESS_LICENSE.
	DocumentTypeBUSINESSLICENSE DocumentType = "BUSINESS_LICENSE"
	// DocumentTypeTAXDOCUMENT is a DocumentType of type TAX_DOCUMENT.
	DocumentTypeTAXDOCUMENT DocumentType = "TAX_DOCUMENT"
	// DocumentTypeBANKSTATEMENT is a DocumentType of type BANK_STATEMENT.
	DocumentTypeBANKSTATEMENT DocumentType = "BANK_STATEMENT"
	// DocumentTypeUTILITYBILL is a DocumentType of type UTILITY_BILL.
	DocumentTypeUTILITYBILL DocumentType = "UTILITY_BILL"
	// DocumentTypeOTHER is a DocumentType of type OTHER.
	DocumentTypeOTHER DocumentType = "OTHER"
)

var ErrInvalidDocumentType = fmt.Errorf("not a valid DocumentType, try [%s]", strings.Join(_DocumentTypeNames, ", "))

var _DocumentTypeNames = []string{
	string(DocumentTypeCERTOFINC),
	string(DocumentTypeOPERATINGAGREEMENT),
	string(DocumentTypeBYLAWS),
	string(DocumentTypePARTNERSHIPAGREEMENT),
	string(DocumentTypeBUSINESSLICENSE),
	string(DocumentTypeTAXDOCUMENT),
	string(DocumentTypeBANKSTATEMENT),
	string(DocumentTypeUTILITYBILL),
	string(DocumentTypeOTHER),
}

// DocumentTypeNames returns a list of possible string values of DocumentType.
func DocumentTypeNames() []string {
	tmp := make([]string, len(_DocumentTypeNames))
	copy(tmp, _DocumentTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x DocumentType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DocumentType) IsValid() bool {
	_, err := ParseDocumentType(string(x))
	return err == nil
}

var _DocumentTypeValue = map[string]DocumentType{
	"CERT_OF_INC":           DocumentTypeCERTOFINC,
	"cert_of_inc":           DocumentTypeCERTOFINC,
	"OPERATING_AGREEMENT":   DocumentTypeOPERATINGAGREEMENT,
	"operating_agreement":   DocumentTypeOPERATINGAGREEMENT,
	"BYLAWS":                DocumentTypeBYLAWS,
	"bylaws":                DocumentTypeBYLAWS,
	"PARTNERSHIP_AGREEMENT": DocumentTypePARTNERSHIPAGREEMENT,
	"partnership_agreement": DocumentTypePARTNERSHIPAGREEMENT,
	"BUSINESS_LICENSE":      DocumentTypeBUSINESSLICENSE,
	"business_license":      DocumentTypeBUSINESSLICENSE,
	"TAX_DOCUMENT":          DocumentTypeTAXDOCUMENT,
	"tax_document":          DocumentTypeTAXDOCUMENT,
	"BANK_STATEMENT":        DocumentTypeBANKSTATEMENT,
	"bank_statement":        DocumentTypeBANKSTATEMENT,
	"UTILITY_BILL":          DocumentTypeUTILITYBILL,
	"utility_bill":          DocumentTypeUTILITYBILL,
	"OTHER":                 DocumentTypeOTHER,
	"other":                 DocumentTypeOTHER,
}

// ParseDocumentType attempts to convert a string to a DocumentType.
func ParseDocumentType(name string) (DocumentType, error) {
	if x, ok := _DocumentTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _DocumentTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return DocumentType(""), fmt.Errorf("%s is %w", name, ErrInvalidDocumentType)
}

// MarshalText implements the text marshaller method.
func (x DocumentType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DocumentType) UnmarshalText(text []byte) error {
	tmp, err := ParseDocumentType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *DocumentType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// GenderM is a Gender of type M.
	GenderM Gender = "M"
	// GenderF is a Gender of type F.
	GenderF Gender = "F"
	// GenderO is a Gender of type O.
	GenderO Gender = "O"
)

var ErrInvalidGender = fmt.Errorf("not a valid Gender, try [%s]", strings.Join(_GenderNames, ", "))

var _GenderNames = []string{
	string(GenderM),
	string(GenderF),
	string(GenderO),
}

// GenderNames returns a list of possible string values of Gender.
func GenderNames() []string {
	tmp := make([]string, len(_GenderNames))
	copy(tmp, _GenderNames)
	return tmp
}

// String implements the Stringer interface.
func (x Gender) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Gender) IsValid() bool {
	_, err := ParseGender(string(x))
	return err == nil
}

var _GenderValue = map[string]Gender{
	"M": GenderM,
	"m": GenderM,
	"F": GenderF,
	"f": GenderF,
	"O": GenderO,
	"o": GenderO,
}

// ParseGender attempts to convert a string to a Gender.
func ParseGender(name string) (Gender, error) {
	if x, ok := _GenderValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _GenderValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Gender(""), fmt.Errorf("%s is %w", name, ErrInvalidGender)
}

// MarshalText implements the text marshaller method.
func (x Gender) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Gender) UnmarshalText(text []byte) error {
	tmp, err := ParseGender(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *Gender) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// HighRiskActivityAdultEntertainment is a HighRiskActivity of type adult_entertainment.
	HighRiskActivityAdultEntertainment HighRiskActivity = "adult_entertainment"
	// HighRiskActivityCannabis is a HighRiskActivity of type cannabis.
	HighRiskActivityCannabis HighRiskActivity = "cannabis"
	// HighRiskActivityCryptocurrency is a HighRiskActivity of type cryptocurrency.
	HighRiskActivityCryptocurrency HighRiskActivity = "cryptocurrency"
	// HighRiskActivityGambling is a HighRiskActivity of type gambling.
	HighRiskActivityGambling HighRiskActivity = "gambling"
	// HighRiskActivityMoneyServices is a HighRiskActivity of type money_services.
	HighRiskActivityMoneyServices HighRiskActivity = "money_services"
	// HighRiskActivityPreciousMetals is a HighRiskActivity of type precious_metals.
	HighRiskActivityPreciousMetals HighRiskActivity = "precious_metals"
	// HighRiskActivityWeapons is a HighRiskActivity of type weapons.
	HighRiskActivityWeapons HighRiskActivity = "weapons"
	// HighRiskActivityNone is a HighRiskActivity of type none.
	HighRiskActivityNone HighRiskActivity = "none"
)

var ErrInvalidHighRiskActivity = fmt.Errorf("not a valid HighRiskActivity, try [%s]", strings.Join(_HighRiskActivityNames, ", "))

var _HighRiskActivityNames = []string{
	string(HighRiskActivityAdultEntertainment),
	string(HighRiskActivityCannabis),
	string(HighRiskActivityCryptocurrency),
	string(HighRiskActivityGambling),
	string(HighRiskActivityMoneyServices),
	string(HighRiskActivityPreciousMetals),
	string(HighRiskActivityWeapons),
	string(HighRiskActivityNone),
}

// HighRiskActivityNames returns a list of possible string values of HighRiskActivity.
func HighRiskActivityNames() []string {
	tmp := make([]string, len(_HighRiskActivityNames))
	copy(tmp, _HighRiskActivityNames)
	return tmp
}

// String implements the Stringer interface.
func (x HighRiskActivity) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HighRiskActivity) IsValid() bool {
	_, err := ParseHighRiskActivity(string(x))
	return err == nil
}

var _HighRiskActivityValue = map[string]HighRiskActivity{
	"adult_entertainment": HighRiskActivityAdultEntertainment,
	"cannabis":            HighRiskActivityCannabis,
	"cryptocurrency":      HighRiskActivityCryptocurrency,
	"gambling":            HighRiskActivityGambling,
	"money_services":      HighRiskActivityMoneyServices,
	"precious_metals":     HighRiskActivityPreciousMetals,
	"weapons":             HighRiskActivityWeapons,
	"none":                HighRiskActivityNone,
}

// ParseHighRiskActivity attempts to convert a string to a HighRiskActivity.
func ParseHighRiskActivity(name string) (HighRiskActivity, error) {
	if x, ok := _HighRiskActivityValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HighRiskActivityValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HighRiskActivity(""), fmt.Errorf("%s is %w", name, ErrInvalidHighRiskActivity)
}

// MarshalText implements the text marshaller method.
func (x HighRiskActivity) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *HighRiskActivity) UnmarshalText(text []byte) error {
	tmp, err := ParseHighRiskActivity(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *HighRiskActivity) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// IDTypeDriversLicense is a IDType of type drivers_license.
	IDTypeDriversLicense IDType = "drivers_license"
	// IDTypePassport is a IDType of type passport.
	IDTypePassport IDType = "passport"
	// IDTypeNationalId is a IDType of type national_id.
	IDTypeNationalId IDType = "national_id"
	// IDTypeStateId is a IDType of type state_id.
	IDTypeStateId IDType = "state_id"
)

var ErrInvalidIDType = fmt.Errorf("not a valid IDType, try [%s]", strings.Join(_IDTypeNames, ", "))

var _IDTypeNames = []string{
	string(IDTypeDriversLicense),
	string(IDTypePassport),
	string(IDTypeNationalId),
	string(IDTypeStateId),
}

// IDTypeNames returns a list of possible string values of IDType.
func IDTypeNames() []string {
	tmp := make([]string, len(_IDTypeNames))
	copy(tmp, _IDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x IDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x IDType) IsValid() bool {
	_, err := ParseIDType(string(x))
	return err == nil
}

var _IDTypeValue = map[string]IDType{
	"drivers_license": IDTypeDriversLicense,
	"passport":        IDTypePassport,
	"national_id":     IDTypeNationalId,
	"state_id":        IDTypeStateId,
}

// ParseIDType attempts to convert a string to a IDType.
func ParseIDType(name string) (IDType, error) {
	if x, ok := _IDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _IDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return IDType(""), fmt.Errorf("%s is %w", name, ErrInvalidIDType)
}

// MarshalText implements the text marshaller method.
func (x IDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *IDType) UnmarshalText(text []byte) error {
	tmp, err := ParseIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *IDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MoneyRange099999 is a MoneyRange of type 0_99999.
	MoneyRange099999 MoneyRange = "0_99999"
	// MoneyRange100000499999 is a MoneyRange of type 100000_499999.
	MoneyRange100000499999 MoneyRange = "100000_499999"
	// MoneyRange500000999999 is a MoneyRange of type 500000_999999.
	MoneyRange500000999999 MoneyRange = "500000_999999"
	// MoneyRange10000004999999 is a MoneyRange of type 1000000_4999999.
	MoneyRange10000004999999 MoneyRange = "1000000_4999999"
	// MoneyRange5000000Plus is a MoneyRange of type 5000000_plus.
	MoneyRange5000000Plus MoneyRange = "5000000_plus"
)

var ErrInvalidMoneyRange = fmt.Errorf("not a valid MoneyRange, try [%s]", strings.Join(_MoneyRangeNames, ", "))

var _MoneyRangeNames = []string{
	string(MoneyRange099999),
	string(MoneyRange100000499999),
	string(MoneyRange500000999999),
	string(MoneyRange10000004999999),
	string(MoneyRange5000000Plus),
}

// MoneyRangeNames returns a list of possible string values of MoneyRange.
func MoneyRangeNames() []string {
	tmp := make([]string, len(_MoneyRangeNames))
	copy(tmp, _MoneyRangeNames)
	return tmp
}

// String implements the Stringer interface.
func (x MoneyRange) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MoneyRange) IsValid() bool {
	_, err := ParseMoneyRange(string(x))
	return err == nil
}

var _MoneyRangeValue = map[string]MoneyRange{
	"0_99999":         MoneyRange099999,
	"100000_499999":   MoneyRange100000499999,
	"500000_999999":   MoneyRange500000999999,
	"1000000_4999999": MoneyRange10000004999999,
	"5000000_plus":    MoneyRange5000000Plus,
}

// ParseMoneyRange attempts to convert a string to a MoneyRange.
func ParseMoneyRange(name string) (MoneyRange, error) {
	if x, ok := _MoneyRangeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _MoneyRangeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return MoneyRange(""), fmt.Errorf("%s is %w", name, ErrInvalidMoneyRange)
}

// MarshalText implements the text marshaller method.
func (x MoneyRange) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MoneyRange) UnmarshalText(text []byte) error {
	tmp, err := ParseMoneyRange(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *MoneyRange) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfFundsBusinessLoans is a SourceOfFunds of type business_loans.
	SourceOfFundsBusinessLoans SourceOfFunds = "business_loans"
	// SourceOfFundsGrants is a SourceOfFunds of type grants.
	SourceOfFundsGrants SourceOfFunds = "grants"
	// SourceOfFundsInterCompanyFunds is a SourceOfFunds of type inter_company_funds.
	SourceOfFundsInterCompanyFunds SourceOfFunds = "inter_company_funds"
	// SourceOfFundsInvestmentProceeds is a SourceOfFunds of type investment_proceeds.
	SourceOfFundsInvestmentProceeds SourceOfFunds = "investment_proceeds"
	// SourceOfFundsLegalSettlement is a SourceOfFunds of type legal_settlement.
	SourceOfFundsLegalSettlement SourceOfFunds = "legal_settlement"
	// SourceOfFundsOwnersCapital is a SourceOfFunds of type owners_capital.
	SourceOfFundsOwnersCapital SourceOfFunds = "owners_capital"
	// SourceOfFundsPensionRetirement is a SourceOfFunds of type pension_retirement.
	SourceOfFundsPensionRetirement SourceOfFunds = "pension_retirement"
	// SourceOfFundsSaleOfAssets is a SourceOfFunds of type sale_of_assets.
	SourceOfFundsSaleOfAssets SourceOfFunds = "sale_of_assets"
	// SourceOfFundsSalesOfGoodsAndServices is a SourceOfFunds of type sales_of_goods_and_services.
	SourceOfFundsSalesOfGoodsAndServices SourceOfFunds = "sales_of_goods_and_services"
	// SourceOfFundsTaxRefund is a SourceOfFunds of type tax_refund.
	SourceOfFundsTaxRefund SourceOfFunds = "tax_refund"
	// SourceOfFundsThirdPartyFunds is a SourceOfFunds of type third_party_funds.
	SourceOfFundsThirdPartyFunds SourceOfFunds = "third_party_funds"
	// SourceOfFundsTreasuryReserves is a SourceOfFunds of type treasury_reserves.
	SourceOfFundsTreasuryReserves SourceOfFunds = "treasury_reserves"
)

var ErrInvalidSourceOfFunds = fmt.Errorf("not a valid SourceOfFunds, try [%s]", strings.Join(_SourceOfFundsNames, ", "))

var _SourceOfFundsNames = []string{
	string(SourceOfFundsBusinessLoans),
	string(SourceOfFundsGrants),
	string(SourceOfFundsInterCompanyFunds),
	string(SourceOfFundsInvestmentProceeds),
	string(SourceOfFundsLegalSettlement),
	string(SourceOfFundsOwnersCapital),
	string(SourceOfFundsPensionRetirement),
	string(SourceOfFundsSaleOfAssets),
	string(SourceOfFundsSalesOfGoodsAndServices),
	string(SourceOfFundsTaxRefund),
	string(SourceOfFundsThirdPartyFunds),
	string(SourceOfFundsTreasuryReserves),
}

// SourceOfFundsNames returns a list of possible string values of SourceOfFunds.
func SourceOfFundsNames() []string {
	tmp := make([]string, len(_SourceOfFundsNames))
	copy(tmp, _SourceOfFundsNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfFunds) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfFunds) IsValid() bool {
	_, err := ParseSourceOfFunds(string(x))
	return err == nil
}

var _SourceOfFundsValue = map[string]SourceOfFunds{
	"business_loans":              SourceOfFundsBusinessLoans,
	"grants":                      SourceOfFundsGrants,
	"inter_company_funds":         SourceOfFundsInterCompanyFunds,
	"investment_proceeds":         SourceOfFundsInvestmentProceeds,
	"legal_settlement":            SourceOfFundsLegalSettlement,
	"owners_capital":              SourceOfFundsOwnersCapital,
	"pension_retirement":          SourceOfFundsPensionRetirement,
	"sale_of_assets":              SourceOfFundsSaleOfAssets,
	"sales_of_goods_and_services": SourceOfFundsSalesOfGoodsAndServices,
	"tax_refund":                  SourceOfFundsTaxRefund,
	"third_party_funds":           SourceOfFundsThirdPartyFunds,
	"treasury_reserves":           SourceOfFundsTreasuryReserves,
}

// ParseSourceOfFunds attempts to convert a string to a SourceOfFunds.
func ParseSourceOfFunds(name string) (SourceOfFunds, error) {
	if x, ok := _SourceOfFundsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfFundsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfFunds(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfFunds)
}

// MarshalText implements the text marshaller method.
func (x SourceOfFunds) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfFunds) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfFunds(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfFunds) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfWealthBusinessDividendsOrProfits is a SourceOfWealth of type business_dividends_or_profits.
	SourceOfWealthBusinessDividendsOrProfits SourceOfWealth = "business_dividends_or_profits"
	// SourceOfWealthSaleOfBusiness is a SourceOfWealth of type sale_of_business.
	SourceOfWealthSaleOfBusiness SourceOfWealth = "sale_of_business"
	// SourceOfWealthInheritance is a SourceOfWealth of type inheritance.
	SourceOfWealthInheritance SourceOfWealth = "inheritance"
	// SourceOfWealthRealEstateInvestments is a SourceOfWealth of type real_estate_investments.
	SourceOfWealthRealEstateInvestments SourceOfWealth = "real_estate_investments"
	// SourceOfWealthInvestmentReturns is a SourceOfWealth of type investment_returns.
	SourceOfWealthInvestmentReturns SourceOfWealth = "investment_returns"
	// SourceOfWealthAccumulatedRevenue is a SourceOfWealth of type accumulated_revenue.
	SourceOfWealthAccumulatedRevenue SourceOfWealth = "accumulated_revenue"
	// SourceOfWealthOther is a SourceOfWealth of type other.
	SourceOfWealthOther SourceOfWealth = "other"
)

var ErrInvalidSourceOfWealth = fmt.Errorf("not a valid SourceOfWealth, try [%s]", strings.Join(_SourceOfWealthNames, ", "))

var _SourceOfWealthNames = []string{
	string(SourceOfWealthBusinessDividendsOrProfits),
	string(SourceOfWealthSaleOfBusiness),
	string(SourceOfWealthInheritance),
	string(SourceOfWealthRealEstateInvestments),
	string(SourceOfWealthInvestmentReturns),
	string(SourceOfWealthAccumulatedRevenue),
	string(SourceOfWealthOther),
}

// SourceOfWealthNames returns a list of possible string values of SourceOfWealth.
func SourceOfWealthNames() []string {
	tmp := make([]string, len(_SourceOfWealthNames))
	copy(tmp, _SourceOfWealthNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfWealth) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfWealth) IsValid() bool {
	_, err := ParseSourceOfWealth(string(x))
	return err == nil
}

var _SourceOfWealthValue = map[string]SourceOfWealth{
	"business_dividends_or_profits": SourceOfWealthBusinessDividendsOrProfits,
	"sale_of_business":              SourceOfWealthSaleOfBusiness,
	"inheritance":                   SourceOfWealthInheritance,
	"real_estate_investments":       SourceOfWealthRealEstateInvestments,
	"investment_returns":            SourceOfWealthInvestmentReturns,
	"accumulated_revenue":           SourceOfWealthAccumulatedRevenue,
	"other":                         SourceOfWealthOther,
}

// ParseSourceOfWealth attempts to convert a string to a SourceOfWealth.
func ParseSourceOfWealth(name string) (SourceOfWealth, error) {
	if x, ok := _SourceOfWealthValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfWealthValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfWealth(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfWealth)
}

// MarshalText implements the text marshaller method.
func (x SourceOfWealth) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfWealth) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfWealth(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfWealth) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TaxIDTypeEIN is a TaxIDType of type EIN.
	TaxIDTypeEIN TaxIDType = "EIN"
	// TaxIDTypeSSN is a TaxIDType of type SSN.
	TaxIDTypeSSN TaxIDType = "SSN"
	// TaxIDTypeTIN is a TaxIDType of type TIN.
	TaxIDTypeTIN TaxIDType = "TIN"
	// TaxIDTypeITIN is a TaxIDType of type ITIN.
	TaxIDTypeITIN TaxIDType = "ITIN"
)

var ErrInvalidTaxIDType = fmt.Errorf("not a valid TaxIDType, try [%s]", strings.Join(_TaxIDTypeNames, ", "))

var _TaxIDTypeNames = []string{
	string(TaxIDTypeEIN),
	string(TaxIDTypeSSN),
	string(TaxIDTypeTIN),
	string(TaxIDTypeITIN),
}

// TaxIDTypeNames returns a list of possible string values of TaxIDType.
func TaxIDTypeNames() []string {
	tmp := make([]string, len(_TaxIDTypeNames))
	copy(tmp, _TaxIDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x TaxIDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TaxIDType) IsValid() bool {
	_, err := ParseTaxIDType(string(x))
	return err == nil
}

var _TaxIDTypeValue = map[string]TaxIDType{
	"EIN":  TaxIDTypeEIN,
	"ein":  TaxIDTypeEIN,
	"SSN":  TaxIDTypeSSN,
	"ssn":  TaxIDTypeSSN,
	"TIN":  TaxIDTypeTIN,
	"tin":  TaxIDTypeTIN,
	"ITIN": TaxIDTypeITIN,
	"itin": TaxIDTypeITIN,
}

// ParseTaxIDType attempts to convert a string to a TaxIDType.
func ParseTaxIDType(name string) (TaxIDType, error) {
	if x, ok := _TaxIDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TaxIDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TaxIDType(""), fmt.Errorf("%s is %w", name, ErrInvalidTaxIDType)
}

// MarshalText implements the text marshaller method.
func (x TaxIDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TaxIDType) UnmarshalText(text []byte) error {
	tmp, err := ParseTaxIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TaxIDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
