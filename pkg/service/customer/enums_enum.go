// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package customer

import (
	"fmt"
	"strings"
)

const (
	// AccountPurposeCharitableDonations is a AccountPurpose of type charitable_donations.
	AccountPurposeCharitableDonations AccountPurpose = "charitable_donations"
	// AccountPurposeEcommerceRetailPayments is a AccountPurpose of type ecommerce_retail_payments.
	AccountPurposeEcommerceRetailPayments AccountPurpose = "ecommerce_retail_payments"
	// AccountPurposeInvestmentPurposes is a AccountPurpose of type investment_purposes.
	AccountPurposeInvestmentPurposes AccountPurpose = "investment_purposes"
	// AccountPurposeOther is a AccountPurpose of type other.
	AccountPurposeOther AccountPurpose = "other"
	// AccountPurposePaymentsToFriendsOrFamilyAbroad is a AccountPurpose of type payments_to_friends_or_family_abroad.
	AccountPurposePaymentsToFriendsOrFamilyAbroad AccountPurpose = "payments_to_friends_or_family_abroad"
	// AccountPurposePayroll is a AccountPurpose of type payroll.
	AccountPurposePayroll AccountPurpose = "payroll"
	// AccountPurposePersonalOrLivingExpenses is a AccountPurpose of type personal_or_living_expenses.
	AccountPurposePersonalOrLivingExpenses AccountPurpose = "personal_or_living_expenses"
	// AccountPurposeProtectWealth is a AccountPurpose of type protect_wealth.
	AccountPurposeProtectWealth AccountPurpose = "protect_wealth"
	// AccountPurposePurchaseGoodsAndServices is a AccountPurpose of type purchase_goods_and_services.
	AccountPurposePurchaseGoodsAndServices AccountPurpose = "purchase_goods_and_services"
	// AccountPurposeReceivePaymentsForGoodsAndServices is a AccountPurpose of type receive_payments_for_goods_and_services.
	AccountPurposeReceivePaymentsForGoodsAndServices AccountPurpose = "receive_payments_for_goods_and_services"
	// AccountPurposeTaxOptimization is a AccountPurpose of type tax_optimization.
	AccountPurposeTaxOptimization AccountPurpose = "tax_optimization"
	// AccountPurposeThirdPartyMoneyTransmission is a AccountPurpose of type third_party_money_transmission.
	AccountPurposeThirdPartyMoneyTransmission AccountPurpose = "third_party_money_transmission"
	// AccountPurposeTreasuryManagement is a AccountPurpose of type treasury_management.
	AccountPurposeTreasuryManagement AccountPurpose = "treasury_management"
)

var ErrInvalidAccountPurpose = fmt.Errorf("not a valid AccountPurpose, try [%s]", strings.Join(_AccountPurposeNames, ", "))

var _AccountPurposeNames = []string{
	string(AccountPurposeCharitableDonations),
	string(AccountPurposeEcommerceRetailPayments),
	string(AccountPurposeInvestmentPurposes),
	string(AccountPurposeOther),
	string(AccountPurposePaymentsToFriendsOrFamilyAbroad),
	string(AccountPurposePayroll),
	string(AccountPurposePersonalOrLivingExpenses),
	string(AccountPurposeProtectWealth),
	string(AccountPurposePurchaseGoodsAndServices),
	string(AccountPurposeReceivePaymentsForGoodsAndServices),
	string(AccountPurposeTaxOptimization),
	string(AccountPurposeThirdPartyMoneyTransmission),
	string(AccountPurposeTreasuryManagement),
}

// AccountPurposeNames returns a list of possible string values of AccountPurpose.
func AccountPurposeNames() []string {
	tmp := make([]string, len(_AccountPurposeNames))
	copy(tmp, _AccountPurposeNames)
	return tmp
}

// String implements the Stringer interface.
func (x AccountPurpose) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AccountPurpose) IsValid() bool {
	_, err := ParseAccountPurpose(string(x))
	return err == nil
}

var _AccountPurposeValue = map[string]AccountPurpose{
	"charitable_donations":                    AccountPurposeCharitableDonations,
	"ecommerce_retail_payments":               AccountPurposeEcommerceRetailPayments,
	"investment_purposes":                     AccountPurposeInvestmentPurposes,
	"other":                                   AccountPurposeOther,
	"payments_to_friends_or_family_abroad":    AccountPurposePaymentsToFriendsOrFamilyAbroad,
	"payroll":                                 AccountPurposePayroll,
	"personal_or_living_expenses":             AccountPurposePersonalOrLivingExpenses,
	"protect_wealth":                          AccountPurposeProtectWealth,
	"purchase_goods_and_services":             AccountPurposePurchaseGoodsAndServices,
	"receive_payments_for_goods_and_services": AccountPurposeReceivePaymentsForGoodsAndServices,
	"tax_optimization":                        AccountPurposeTaxOptimization,
	"third_party_money_transmission":          AccountPurposeThirdPartyMoneyTransmission,
	"treasury_management":                     AccountPurposeTreasuryManagement,
}

// ParseAccountPurpose attempts to convert a string to a AccountPurpose.
func ParseAccountPurpose(name string) (AccountPurpose, error) {
	if x, ok := _AccountPurposeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _AccountPurposeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return AccountPurpose(""), fmt.Errorf("%s is %w", name, ErrInvalidAccountPurpose)
}

// MarshalText implements the text marshaller method.
func (x AccountPurpose) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *AccountPurpose) UnmarshalText(text []byte) error {
	tmp, err := ParseAccountPurpose(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *AccountPurpose) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution is a BusinessIndustry of type bank_credit_unions_regulated_financial_institution.
	BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution BusinessIndustry = "bank_credit_unions_regulated_financial_institution"
	// BusinessIndustryProfessionalServices is a BusinessIndustry of type professional_services.
	BusinessIndustryProfessionalServices BusinessIndustry = "professional_services"
	// BusinessIndustryTechnologyECommercePlatforms is a BusinessIndustry of type technology_e_commerce_platforms.
	BusinessIndustryTechnologyECommercePlatforms BusinessIndustry = "technology_e_commerce_platforms"
	// BusinessIndustryGeneralManufacturing is a BusinessIndustry of type general_manufacturing.
	BusinessIndustryGeneralManufacturing BusinessIndustry = "general_manufacturing"
	// BusinessIndustryGeneralWholesalers is a BusinessIndustry of type general_wholesalers.
	BusinessIndustryGeneralWholesalers BusinessIndustry = "general_wholesalers"
	// BusinessIndustryHealthcareAndSocialAssistance is a BusinessIndustry of type healthcare_and_social_assistance.
	BusinessIndustryHealthcareAndSocialAssistance BusinessIndustry = "healthcare_and_social_assistance"
	// BusinessIndustryEducationalServices is a BusinessIndustry of type educational_services.
	BusinessIndustryEducationalServices BusinessIndustry = "educational_services"
	// BusinessIndustryScientificAndTechnicalServices is a BusinessIndustry of type scientific_and_technical_services.
	BusinessIndustryScientificAndTechnicalServices BusinessIndustry = "scientific_and_technical_services"
	// BusinessIndustryNonBankFinancialInstitution is a BusinessIndustry of type non_bank_financial_institution.
	BusinessIndustryNonBankFinancialInstitution BusinessIndustry = "non_bank_financial_institution"
	// BusinessIndustryInvestmentFund is a BusinessIndustry of type investment_fund.
	BusinessIndustryInvestmentFund BusinessIndustry = "investment_fund"
	// BusinessIndustryRealEstate is a BusinessIndustry of type real_estate.
	BusinessIndustryRealEstate BusinessIndustry = "real_estate"
	// BusinessIndustryRetailTrade is a BusinessIndustry of type retail_trade.
	BusinessIndustryRetailTrade BusinessIndustry = "retail_trade"
	// BusinessIndustryArtsEntertainmentRecreation is a BusinessIndustry of type arts_entertainment_recreation.
	BusinessIndustryArtsEntertainmentRecreation BusinessIndustry = "arts_entertainment_recreation"
	// BusinessIndustryAccommodationFoodServices is a BusinessIndustry of type accommodation_food_services.
	BusinessIndustryAccommodationFoodServices BusinessIndustry = "accommodation_food_services"
	// BusinessIndustryOther is a BusinessIndustry of type other.
	BusinessIndustryOther BusinessIndustry = "other"
)

var ErrInvalidBusinessIndustry = fmt.Errorf("not a valid BusinessIndustry, try [%s]", strings.Join(_BusinessIndustryNames, ", "))

var _BusinessIndustryNames = []string{
	string(BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution),
	string(BusinessIndustryProfessionalServices),
	string(BusinessIndustryTechnologyECommercePlatforms),
	string(BusinessIndustryGeneralManufacturing),
	string(BusinessIndustryGeneralWholesalers),
	string(BusinessIndustryHealthcareAndSocialAssistance),
	string(BusinessIndustryEducationalServices),
	string(BusinessIndustryScientificAndTechnicalServices),
	string(BusinessIndustryNonBankFinancialInstitution),
	string(BusinessIndustryInvestmentFund),
	string(BusinessIndustryRealEstate),
	string(BusinessIndustryRetailTrade),
	string(BusinessIndustryArtsEntertainmentRecreation),
	string(BusinessIndustryAccommodationFoodServices),
	string(BusinessIndustryOther),
}

// BusinessIndustryNames returns a list of possible string values of BusinessIndustry.
func BusinessIndustryNames() []string {
	tmp := make([]string, len(_BusinessIndustryNames))
	copy(tmp, _BusinessIndustryNames)
	return tmp
}

// String implements the Stringer interface.
func (x BusinessIndustry) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BusinessIndustry) IsValid() bool {
	_, err := ParseBusinessIndustry(string(x))
	return err == nil
}

var _BusinessIndustryValue = map[string]BusinessIndustry{
	"bank_credit_unions_regulated_financial_institution": BusinessIndustryBankCreditUnionsRegulatedFinancialInstitution,
	"professional_services":                              BusinessIndustryProfessionalServices,
	"technology_e_commerce_platforms":                    BusinessIndustryTechnologyECommercePlatforms,
	"general_manufacturing":                              BusinessIndustryGeneralManufacturing,
	"general_wholesalers":                                BusinessIndustryGeneralWholesalers,
	"healthcare_and_social_assistance":                   BusinessIndustryHealthcareAndSocialAssistance,
	"educational_services":                               BusinessIndustryEducationalServices,
	"scientific_and_technical_services":                  BusinessIndustryScientificAndTechnicalServices,
	"non_bank_financial_institution":                     BusinessIndustryNonBankFinancialInstitution,
	"investment_fund":                                    BusinessIndustryInvestmentFund,
	"real_estate":                                        BusinessIndustryRealEstate,
	"retail_trade":                                       BusinessIndustryRetailTrade,
	"arts_entertainment_recreation":                      BusinessIndustryArtsEntertainmentRecreation,
	"accommodation_food_services":                        BusinessIndustryAccommodationFoodServices,
	"other":                                              BusinessIndustryOther,
}

// ParseBusinessIndustry attempts to convert a string to a BusinessIndustry.
func ParseBusinessIndustry(name string) (BusinessIndustry, error) {
	if x, ok := _BusinessIndustryValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BusinessIndustryValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BusinessIndustry(""), fmt.Errorf("%s is %w", name, ErrInvalidBusinessIndustry)
}

// MarshalText implements the text marshaller method.
func (x BusinessIndustry) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BusinessIndustry) UnmarshalText(text []byte) error {
	tmp, err := ParseBusinessIndustry(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BusinessIndustry) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// BusinessTypeCooperative is a BusinessType of type cooperative.
	BusinessTypeCooperative BusinessType = "cooperative"
	// BusinessTypeCorporation is a BusinessType of type corporation.
	BusinessTypeCorporation BusinessType = "corporation"
	// BusinessTypeLlc is a BusinessType of type llc.
	BusinessTypeLlc BusinessType = "llc"
	// BusinessTypePartnership is a BusinessType of type partnership.
	BusinessTypePartnership BusinessType = "partnership"
	// BusinessTypeSoleProprietorship is a BusinessType of type sole_proprietorship.
	BusinessTypeSoleProprietorship BusinessType = "sole_proprietorship"
)

var ErrInvalidBusinessType = fmt.Errorf("not a valid BusinessType, try [%s]", strings.Join(_BusinessTypeNames, ", "))

var _BusinessTypeNames = []string{
	string(BusinessTypeCooperative),
	string(BusinessTypeCorporation),
	string(BusinessTypeLlc),
	string(BusinessTypePartnership),
	string(BusinessTypeSoleProprietorship),
}

// BusinessTypeNames returns a list of possible string values of BusinessType.
func BusinessTypeNames() []string {
	tmp := make([]string, len(_BusinessTypeNames))
	copy(tmp, _BusinessTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x BusinessType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BusinessType) IsValid() bool {
	_, err := ParseBusinessType(string(x))
	return err == nil
}

var _BusinessTypeValue = map[string]BusinessType{
	"cooperative":         BusinessTypeCooperative,
	"corporation":         BusinessTypeCorporation,
	"llc":                 BusinessTypeLlc,
	"partnership":         BusinessTypePartnership,
	"sole_proprietorship": BusinessTypeSoleProprietorship,
}

// ParseBusinessType attempts to convert a string to a BusinessType.
func ParseBusinessType(name string) (BusinessType, error) {
	if x, ok := _BusinessTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BusinessTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BusinessType(""), fmt.Errorf("%s is %w", name, ErrInvalidBusinessType)
}

// MarshalText implements the text marshaller method.
func (x BusinessType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BusinessType) UnmarshalText(text []byte) error {
	tmp, err := ParseBusinessType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BusinessType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// CustomerStatusActive is a CustomerStatus of type active.
	CustomerStatusActive CustomerStatus = "active"
	// CustomerStatusAwaitingQuestionnaire is a CustomerStatus of type awaiting_questionnaire.
	CustomerStatusAwaitingQuestionnaire CustomerStatus = "awaiting_questionnaire"
	// CustomerStatusAwaitingUbo is a CustomerStatus of type awaiting_ubo.
	CustomerStatusAwaitingUbo CustomerStatus = "awaiting_ubo"
	// CustomerStatusIncomplete is a CustomerStatus of type incomplete.
	CustomerStatusIncomplete CustomerStatus = "incomplete"
	// CustomerStatusNotStarted is a CustomerStatus of type not_started.
	CustomerStatusNotStarted CustomerStatus = "not_started"
	// CustomerStatusOffboarded is a CustomerStatus of type offboarded.
	CustomerStatusOffboarded CustomerStatus = "offboarded"
	// CustomerStatusPaused is a CustomerStatus of type paused.
	CustomerStatusPaused CustomerStatus = "paused"
	// CustomerStatusRejected is a CustomerStatus of type rejected.
	CustomerStatusRejected CustomerStatus = "rejected"
	// CustomerStatusUnderReview is a CustomerStatus of type under_review.
	CustomerStatusUnderReview CustomerStatus = "under_review"
)

var ErrInvalidCustomerStatus = fmt.Errorf("not a valid CustomerStatus, try [%s]", strings.Join(_CustomerStatusNames, ", "))

var _CustomerStatusNames = []string{
	string(CustomerStatusActive),
	string(CustomerStatusAwaitingQuestionnaire),
	string(CustomerStatusAwaitingUbo),
	string(CustomerStatusIncomplete),
	string(CustomerStatusNotStarted),
	string(CustomerStatusOffboarded),
	string(CustomerStatusPaused),
	string(CustomerStatusRejected),
	string(CustomerStatusUnderReview),
}

// CustomerStatusNames returns a list of possible string values of CustomerStatus.
func CustomerStatusNames() []string {
	tmp := make([]string, len(_CustomerStatusNames))
	copy(tmp, _CustomerStatusNames)
	return tmp
}

// String implements the Stringer interface.
func (x CustomerStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CustomerStatus) IsValid() bool {
	_, err := ParseCustomerStatus(string(x))
	return err == nil
}

var _CustomerStatusValue = map[string]CustomerStatus{
	"active":                 CustomerStatusActive,
	"awaiting_questionnaire": CustomerStatusAwaitingQuestionnaire,
	"awaiting_ubo":           CustomerStatusAwaitingUbo,
	"incomplete":             CustomerStatusIncomplete,
	"not_started":            CustomerStatusNotStarted,
	"offboarded":             CustomerStatusOffboarded,
	"paused":                 CustomerStatusPaused,
	"rejected":               CustomerStatusRejected,
	"under_review":           CustomerStatusUnderReview,
}

// ParseCustomerStatus attempts to convert a string to a CustomerStatus.
func ParseCustomerStatus(name string) (CustomerStatus, error) {
	if x, ok := _CustomerStatusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _CustomerStatusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return CustomerStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidCustomerStatus)
}

// MarshalText implements the text marshaller method.
func (x CustomerStatus) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CustomerStatus) UnmarshalText(text []byte) error {
	tmp, err := ParseCustomerStatus(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *CustomerStatus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// DocumentTypeCertificateOfIncorporation is a DocumentType of type certificate_of_incorporation.
	DocumentTypeCertificateOfIncorporation DocumentType = "certificate_of_incorporation"
	// DocumentTypeCertificateOfFormationRegistration is a DocumentType of type certificate_of_formation_registration.
	DocumentTypeCertificateOfFormationRegistration DocumentType = "certificate_of_formation_registration"
	// DocumentTypeCertificateOfIncorporationAndArticlesOfOrganization is a DocumentType of type certificate_of_incorporation_and_articles_of_organization.
	DocumentTypeCertificateOfIncorporationAndArticlesOfOrganization DocumentType = "certificate_of_incorporation_and_articles_of_organization"
	// DocumentTypeConstitutionalOrFormationDocuments is a DocumentType of type constitutional_or_formation_documents.
	DocumentTypeConstitutionalOrFormationDocuments DocumentType = "constitutional_or_formation_documents"
	// DocumentTypePartnershipAgreement is a DocumentType of type partnership_agreement.
	DocumentTypePartnershipAgreement DocumentType = "partnership_agreement"
	// DocumentTypeArticlesOfOrganization is a DocumentType of type articles_of_organization.
	DocumentTypeArticlesOfOrganization DocumentType = "articles_of_organization"
	// DocumentTypeArticlesOfIncorporation is a DocumentType of type articles_of_incorporation.
	DocumentTypeArticlesOfIncorporation DocumentType = "articles_of_incorporation"
	// DocumentTypeOperatingLpAgreementIfApplicable is a DocumentType of type operating_lp_agreement_if_applicable.
	DocumentTypeOperatingLpAgreementIfApplicable DocumentType = "operating_lp_agreement_if_applicable"
	// DocumentTypeProspectusOfferingMemorandumOrPrivatePlacementMemorandum is a DocumentType of type prospectus_offering_memorandum_or_private_placement_memorandum.
	DocumentTypeProspectusOfferingMemorandumOrPrivatePlacementMemorandum DocumentType = "prospectus_offering_memorandum_or_private_placement_memorandum"
	// DocumentTypeAmlAttestationLetter is a DocumentType of type aml_attestation_letter.
	DocumentTypeAmlAttestationLetter DocumentType = "aml_attestation_letter"
	// DocumentTypeFundStructureChart is a DocumentType of type fund_structure_chart.
	DocumentTypeFundStructureChart DocumentType = "fund_structure_chart"
	// DocumentTypeArticlesOfIncorporationByLawsOrEquivalentDocument is a DocumentType of type articles_of_incorporation_by_laws_or_equivalent_document.
	DocumentTypeArticlesOfIncorporationByLawsOrEquivalentDocument DocumentType = "articles_of_incorporation_by_laws_or_equivalent_document"
	// DocumentTypeIrsDeterminationLetter is a DocumentType of type irs_determination_letter.
	DocumentTypeIrsDeterminationLetter DocumentType = "irs_determination_letter"
	// DocumentTypeAnnualReports is a DocumentType of type annual_reports.
	DocumentTypeAnnualReports DocumentType = "annual_reports"
	// DocumentTypeBusinessLicense is a DocumentType of type business_license.
	DocumentTypeBusinessLicense DocumentType = "business_license"
	// DocumentTypeTradeNameRegistrationDoingBusinessAsDbaFiling is a DocumentType of type trade_name_registration_doing_business_as_dba_filing.
	DocumentTypeTradeNameRegistrationDoingBusinessAsDbaFiling DocumentType = "trade_name_registration_doing_business_as_dba_filing"
	// DocumentTypeTaxFilings is a DocumentType of type tax_filings.
	DocumentTypeTaxFilings DocumentType = "tax_filings"
	// DocumentTypeListManagerOrSimilarPersonsThatHasHaveTheAbilityToLegallyBindTheDaoAndCarryOutTheDaosInstructions is a DocumentType of type list_manager_or_similar_persons_that_has_have_the_ability_to_legally_bind_the_dao_and_carry_out_the_daos_instructions.
	DocumentTypeListManagerOrSimilarPersonsThatHasHaveTheAbilityToLegallyBindTheDaoAndCarryOutTheDaosInstructions DocumentType = "list_manager_or_similar_persons_that_has_have_the_ability_to_legally_bind_the_dao_and_carry_out_the_daos_instructions"
	// DocumentTypeVotingRecords is a DocumentType of type voting_records.
	DocumentTypeVotingRecords DocumentType = "voting_records"
	// DocumentTypeTrustAgreement is a DocumentType of type trust_agreement.
	DocumentTypeTrustAgreement DocumentType = "trust_agreement"
	// DocumentTypeCertificateOfGoodStanding is a DocumentType of type certificate_of_good_standing.
	DocumentTypeCertificateOfGoodStanding DocumentType = "certificate_of_good_standing"
	// DocumentTypeOwnershipAndFormationDocuments is a DocumentType of type ownership_and_formation_documents.
	DocumentTypeOwnershipAndFormationDocuments DocumentType = "ownership_and_formation_documents"
	// DocumentTypeOwnershipStructureLlc is a DocumentType of type ownership_structure_llc.
	DocumentTypeOwnershipStructureLlc DocumentType = "ownership_structure_llc"
	// DocumentTypeOwnershipStructureCorp is a DocumentType of type ownership_structure_corp.
	DocumentTypeOwnershipStructureCorp DocumentType = "ownership_structure_corp"
	// DocumentTypeOwnershipStructurePart is a DocumentType of type ownership_structure_part.
	DocumentTypeOwnershipStructurePart DocumentType = "ownership_structure_part"
	// DocumentTypeOwnershipStructureDao is a DocumentType of type ownership_structure_dao.
	DocumentTypeOwnershipStructureDao DocumentType = "ownership_structure_dao"
	// DocumentTypeOwnershipStructureGov is a DocumentType of type ownership_structure_gov.
	DocumentTypeOwnershipStructureGov DocumentType = "ownership_structure_gov"
	// DocumentTypeAuthorizedRepresentativeList is a DocumentType of type authorized_representative_list.
	DocumentTypeAuthorizedRepresentativeList DocumentType = "authorized_representative_list"
	// DocumentTypeProofOfSourceOfFunds is a DocumentType of type proof_of_source_of_funds.
	DocumentTypeProofOfSourceOfFunds DocumentType = "proof_of_source_of_funds"
	// DocumentTypeProofOfBusinessEntityAddress is a DocumentType of type proof_of_business_entity_address.
	DocumentTypeProofOfBusinessEntityAddress DocumentType = "proof_of_business_entity_address"
	// DocumentTypeProofOfBusinessEntityAddressDao is a DocumentType of type proof_of_business_entity_address_dao.
	DocumentTypeProofOfBusinessEntityAddressDao DocumentType = "proof_of_business_entity_address_dao"
	// DocumentTypeW9Form is a DocumentType of type w9_form.
	DocumentTypeW9Form DocumentType = "w9_form"
	// DocumentTypeStateLocalMoneyTransmissionLicensingEvidenceOrEquivalentRegulatoryAuthorizationNonUs is a DocumentType of type state_local_money_transmission_licensing_evidence_or_equivalent_regulatory_authorization_non_us.
	DocumentTypeStateLocalMoneyTransmissionLicensingEvidenceOrEquivalentRegulatoryAuthorizationNonUs DocumentType = "state_local_money_transmission_licensing_evidence_or_equivalent_regulatory_authorization_non_us"
	// DocumentTypeAmlPolicy is a DocumentType of type aml_policy.
	DocumentTypeAmlPolicy DocumentType = "aml_policy"
	// DocumentTypeCertificateOfIncumbencyOrRegisterOfDirectors is a DocumentType of type certificate_of_incumbency_or_register_of_directors.
	DocumentTypeCertificateOfIncumbencyOrRegisterOfDirectors DocumentType = "certificate_of_incumbency_or_register_of_directors"
	// DocumentTypeTaxExemptionOrCharityRegistrationLetter is a DocumentType of type tax_exemption_or_charity_registration_letter.
	DocumentTypeTaxExemptionOrCharityRegistrationLetter DocumentType = "tax_exemption_or_charity_registration_letter"
	// DocumentTypeMemorandumOfAssociationOrArticleOfAssociationOrEquivalentDocument is a DocumentType of type memorandum_of_association_or_article_of_association_or_equivalent_document.
	DocumentTypeMemorandumOfAssociationOrArticleOfAssociationOrEquivalentDocument DocumentType = "memorandum_of_association_or_article_of_association_or_equivalent_document"
	// DocumentTypeSupportingDocuments is a DocumentType of type supporting_documents.
	DocumentTypeSupportingDocuments DocumentType = "supporting_documents"
)

var ErrInvalidDocumentType = fmt.Errorf("not a valid DocumentType, try [%s]", strings.Join(_DocumentTypeNames, ", "))

var _DocumentTypeNames = []string{
	string(DocumentTypeCertificateOfIncorporation),
	string(DocumentTypeCertificateOfFormationRegistration),
	string(DocumentTypeCertificateOfIncorporationAndArticlesOfOrganization),
	string(DocumentTypeConstitutionalOrFormationDocuments),
	string(DocumentTypePartnershipAgreement),
	string(DocumentTypeArticlesOfOrganization),
	string(DocumentTypeArticlesOfIncorporation),
	string(DocumentTypeOperatingLpAgreementIfApplicable),
	string(DocumentTypeProspectusOfferingMemorandumOrPrivatePlacementMemorandum),
	string(DocumentTypeAmlAttestationLetter),
	string(DocumentTypeFundStructureChart),
	string(DocumentTypeArticlesOfIncorporationByLawsOrEquivalentDocument),
	string(DocumentTypeIrsDeterminationLetter),
	string(DocumentTypeAnnualReports),
	string(DocumentTypeBusinessLicense),
	string(DocumentTypeTradeNameRegistrationDoingBusinessAsDbaFiling),
	string(DocumentTypeTaxFilings),
	string(DocumentTypeListManagerOrSimilarPersonsThatHasHaveTheAbilityToLegallyBindTheDaoAndCarryOutTheDaosInstructions),
	string(DocumentTypeVotingRecords),
	string(DocumentTypeTrustAgreement),
	string(DocumentTypeCertificateOfGoodStanding),
	string(DocumentTypeOwnershipAndFormationDocuments),
	string(DocumentTypeOwnershipStructureLlc),
	string(DocumentTypeOwnershipStructureCorp),
	string(DocumentTypeOwnershipStructurePart),
	string(DocumentTypeOwnershipStructureDao),
	string(DocumentTypeOwnershipStructureGov),
	string(DocumentTypeAuthorizedRepresentativeList),
	string(DocumentTypeProofOfSourceOfFunds),
	string(DocumentTypeProofOfBusinessEntityAddress),
	string(DocumentTypeProofOfBusinessEntityAddressDao),
	string(DocumentTypeW9Form),
	string(DocumentTypeStateLocalMoneyTransmissionLicensingEvidenceOrEquivalentRegulatoryAuthorizationNonUs),
	string(DocumentTypeAmlPolicy),
	string(DocumentTypeCertificateOfIncumbencyOrRegisterOfDirectors),
	string(DocumentTypeTaxExemptionOrCharityRegistrationLetter),
	string(DocumentTypeMemorandumOfAssociationOrArticleOfAssociationOrEquivalentDocument),
	string(DocumentTypeSupportingDocuments),
}

// DocumentTypeNames returns a list of possible string values of DocumentType.
func DocumentTypeNames() []string {
	tmp := make([]string, len(_DocumentTypeNames))
	copy(tmp, _DocumentTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x DocumentType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x DocumentType) IsValid() bool {
	_, err := ParseDocumentType(string(x))
	return err == nil
}

var _DocumentTypeValue = map[string]DocumentType{
	"certificate_of_incorporation":                                   DocumentTypeCertificateOfIncorporation,
	"certificate_of_formation_registration":                          DocumentTypeCertificateOfFormationRegistration,
	"certificate_of_incorporation_and_articles_of_organization":      DocumentTypeCertificateOfIncorporationAndArticlesOfOrganization,
	"constitutional_or_formation_documents":                          DocumentTypeConstitutionalOrFormationDocuments,
	"partnership_agreement":                                          DocumentTypePartnershipAgreement,
	"articles_of_organization":                                       DocumentTypeArticlesOfOrganization,
	"articles_of_incorporation":                                      DocumentTypeArticlesOfIncorporation,
	"operating_lp_agreement_if_applicable":                           DocumentTypeOperatingLpAgreementIfApplicable,
	"prospectus_offering_memorandum_or_private_placement_memorandum": DocumentTypeProspectusOfferingMemorandumOrPrivatePlacementMemorandum,
	"aml_attestation_letter":                                         DocumentTypeAmlAttestationLetter,
	"fund_structure_chart":                                           DocumentTypeFundStructureChart,
	"articles_of_incorporation_by_laws_or_equivalent_document":       DocumentTypeArticlesOfIncorporationByLawsOrEquivalentDocument,
	"irs_determination_letter":                                       DocumentTypeIrsDeterminationLetter,
	"annual_reports":                                                 DocumentTypeAnnualReports,
	"business_license":                                               DocumentTypeBusinessLicense,
	"trade_name_registration_doing_business_as_dba_filing":           DocumentTypeTradeNameRegistrationDoingBusinessAsDbaFiling,
	"tax_filings":                                                    DocumentTypeTaxFilings,
	"list_manager_or_similar_persons_that_has_have_the_ability_to_legally_bind_the_dao_and_carry_out_the_daos_instructions": DocumentTypeListManagerOrSimilarPersonsThatHasHaveTheAbilityToLegallyBindTheDaoAndCarryOutTheDaosInstructions,
	"voting_records":                       DocumentTypeVotingRecords,
	"trust_agreement":                      DocumentTypeTrustAgreement,
	"certificate_of_good_standing":         DocumentTypeCertificateOfGoodStanding,
	"ownership_and_formation_documents":    DocumentTypeOwnershipAndFormationDocuments,
	"ownership_structure_llc":              DocumentTypeOwnershipStructureLlc,
	"ownership_structure_corp":             DocumentTypeOwnershipStructureCorp,
	"ownership_structure_part":             DocumentTypeOwnershipStructurePart,
	"ownership_structure_dao":              DocumentTypeOwnershipStructureDao,
	"ownership_structure_gov":              DocumentTypeOwnershipStructureGov,
	"authorized_representative_list":       DocumentTypeAuthorizedRepresentativeList,
	"proof_of_source_of_funds":             DocumentTypeProofOfSourceOfFunds,
	"proof_of_business_entity_address":     DocumentTypeProofOfBusinessEntityAddress,
	"proof_of_business_entity_address_dao": DocumentTypeProofOfBusinessEntityAddressDao,
	"w9_form":                              DocumentTypeW9Form,
	"state_local_money_transmission_licensing_evidence_or_equivalent_regulatory_authorization_non_us": DocumentTypeStateLocalMoneyTransmissionLicensingEvidenceOrEquivalentRegulatoryAuthorizationNonUs,
	"aml_policy": DocumentTypeAmlPolicy,
	"certificate_of_incumbency_or_register_of_directors":                         DocumentTypeCertificateOfIncumbencyOrRegisterOfDirectors,
	"tax_exemption_or_charity_registration_letter":                               DocumentTypeTaxExemptionOrCharityRegistrationLetter,
	"memorandum_of_association_or_article_of_association_or_equivalent_document": DocumentTypeMemorandumOfAssociationOrArticleOfAssociationOrEquivalentDocument,
	"supporting_documents": DocumentTypeSupportingDocuments,
}

// ParseDocumentType attempts to convert a string to a DocumentType.
func ParseDocumentType(name string) (DocumentType, error) {
	if x, ok := _DocumentTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _DocumentTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return DocumentType(""), fmt.Errorf("%s is %w", name, ErrInvalidDocumentType)
}

// MarshalText implements the text marshaller method.
func (x DocumentType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *DocumentType) UnmarshalText(text []byte) error {
	tmp, err := ParseDocumentType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *DocumentType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// HighRiskActivityAdultEntertainment is a HighRiskActivity of type adult_entertainment.
	HighRiskActivityAdultEntertainment HighRiskActivity = "adult_entertainment"
	// HighRiskActivityCannabis is a HighRiskActivity of type cannabis.
	HighRiskActivityCannabis HighRiskActivity = "cannabis"
	// HighRiskActivityCryptocurrency is a HighRiskActivity of type cryptocurrency.
	HighRiskActivityCryptocurrency HighRiskActivity = "cryptocurrency"
	// HighRiskActivityGambling is a HighRiskActivity of type gambling.
	HighRiskActivityGambling HighRiskActivity = "gambling"
	// HighRiskActivityMoneyServices is a HighRiskActivity of type money_services.
	HighRiskActivityMoneyServices HighRiskActivity = "money_services"
	// HighRiskActivityPreciousMetals is a HighRiskActivity of type precious_metals.
	HighRiskActivityPreciousMetals HighRiskActivity = "precious_metals"
	// HighRiskActivityWeapons is a HighRiskActivity of type weapons.
	HighRiskActivityWeapons HighRiskActivity = "weapons"
	// HighRiskActivityNone is a HighRiskActivity of type none.
	HighRiskActivityNone HighRiskActivity = "none"
)

var ErrInvalidHighRiskActivity = fmt.Errorf("not a valid HighRiskActivity, try [%s]", strings.Join(_HighRiskActivityNames, ", "))

var _HighRiskActivityNames = []string{
	string(HighRiskActivityAdultEntertainment),
	string(HighRiskActivityCannabis),
	string(HighRiskActivityCryptocurrency),
	string(HighRiskActivityGambling),
	string(HighRiskActivityMoneyServices),
	string(HighRiskActivityPreciousMetals),
	string(HighRiskActivityWeapons),
	string(HighRiskActivityNone),
}

// HighRiskActivityNames returns a list of possible string values of HighRiskActivity.
func HighRiskActivityNames() []string {
	tmp := make([]string, len(_HighRiskActivityNames))
	copy(tmp, _HighRiskActivityNames)
	return tmp
}

// String implements the Stringer interface.
func (x HighRiskActivity) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x HighRiskActivity) IsValid() bool {
	_, err := ParseHighRiskActivity(string(x))
	return err == nil
}

var _HighRiskActivityValue = map[string]HighRiskActivity{
	"adult_entertainment": HighRiskActivityAdultEntertainment,
	"cannabis":            HighRiskActivityCannabis,
	"cryptocurrency":      HighRiskActivityCryptocurrency,
	"gambling":            HighRiskActivityGambling,
	"money_services":      HighRiskActivityMoneyServices,
	"precious_metals":     HighRiskActivityPreciousMetals,
	"weapons":             HighRiskActivityWeapons,
	"none":                HighRiskActivityNone,
}

// ParseHighRiskActivity attempts to convert a string to a HighRiskActivity.
func ParseHighRiskActivity(name string) (HighRiskActivity, error) {
	if x, ok := _HighRiskActivityValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _HighRiskActivityValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return HighRiskActivity(""), fmt.Errorf("%s is %w", name, ErrInvalidHighRiskActivity)
}

// MarshalText implements the text marshaller method.
func (x HighRiskActivity) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *HighRiskActivity) UnmarshalText(text []byte) error {
	tmp, err := ParseHighRiskActivity(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *HighRiskActivity) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// IDTypeDriversLicense is a IDType of type drivers_license.
	IDTypeDriversLicense IDType = "drivers_license"
	// IDTypePassport is a IDType of type passport.
	IDTypePassport IDType = "passport"
	// IDTypeNationalId is a IDType of type national_id.
	IDTypeNationalId IDType = "national_id"
	// IDTypeStateId is a IDType of type state_id.
	IDTypeStateId IDType = "state_id"
)

var ErrInvalidIDType = fmt.Errorf("not a valid IDType, try [%s]", strings.Join(_IDTypeNames, ", "))

var _IDTypeNames = []string{
	string(IDTypeDriversLicense),
	string(IDTypePassport),
	string(IDTypeNationalId),
	string(IDTypeStateId),
}

// IDTypeNames returns a list of possible string values of IDType.
func IDTypeNames() []string {
	tmp := make([]string, len(_IDTypeNames))
	copy(tmp, _IDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x IDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x IDType) IsValid() bool {
	_, err := ParseIDType(string(x))
	return err == nil
}

var _IDTypeValue = map[string]IDType{
	"drivers_license": IDTypeDriversLicense,
	"passport":        IDTypePassport,
	"national_id":     IDTypeNationalId,
	"state_id":        IDTypeStateId,
}

// ParseIDType attempts to convert a string to a IDType.
func ParseIDType(name string) (IDType, error) {
	if x, ok := _IDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _IDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return IDType(""), fmt.Errorf("%s is %w", name, ErrInvalidIDType)
}

// MarshalText implements the text marshaller method.
func (x IDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *IDType) UnmarshalText(text []byte) error {
	tmp, err := ParseIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *IDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageFormatJpeg is a ImageFormat of type jpeg.
	ImageFormatJpeg ImageFormat = "jpeg"
	// ImageFormatJpg is a ImageFormat of type jpg.
	ImageFormatJpg ImageFormat = "jpg"
	// ImageFormatPng is a ImageFormat of type png.
	ImageFormatPng ImageFormat = "png"
	// ImageFormatHeic is a ImageFormat of type heic.
	ImageFormatHeic ImageFormat = "heic"
	// ImageFormatTif is a ImageFormat of type tif.
	ImageFormatTif ImageFormat = "tif"
)

var ErrInvalidImageFormat = fmt.Errorf("not a valid ImageFormat, try [%s]", strings.Join(_ImageFormatNames, ", "))

var _ImageFormatNames = []string{
	string(ImageFormatJpeg),
	string(ImageFormatJpg),
	string(ImageFormatPng),
	string(ImageFormatHeic),
	string(ImageFormatTif),
}

// ImageFormatNames returns a list of possible string values of ImageFormat.
func ImageFormatNames() []string {
	tmp := make([]string, len(_ImageFormatNames))
	copy(tmp, _ImageFormatNames)
	return tmp
}

// String implements the Stringer interface.
func (x ImageFormat) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageFormat) IsValid() bool {
	_, err := ParseImageFormat(string(x))
	return err == nil
}

var _ImageFormatValue = map[string]ImageFormat{
	"jpeg": ImageFormatJpeg,
	"jpg":  ImageFormatJpg,
	"png":  ImageFormatPng,
	"heic": ImageFormatHeic,
	"tif":  ImageFormatTif,
}

// ParseImageFormat attempts to convert a string to a ImageFormat.
func ParseImageFormat(name string) (ImageFormat, error) {
	if x, ok := _ImageFormatValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ImageFormatValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ImageFormat(""), fmt.Errorf("%s is %w", name, ErrInvalidImageFormat)
}

// MarshalText implements the text marshaller method.
func (x ImageFormat) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageFormat) UnmarshalText(text []byte) error {
	tmp, err := ParseImageFormat(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageFormat) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MoneyRange099999 is a MoneyRange of type 0_99999.
	MoneyRange099999 MoneyRange = "0_99999"
	// MoneyRange100000499999 is a MoneyRange of type 100000_499999.
	MoneyRange100000499999 MoneyRange = "100000_499999"
	// MoneyRange500000999999 is a MoneyRange of type 500000_999999.
	MoneyRange500000999999 MoneyRange = "500000_999999"
	// MoneyRange10000004999999 is a MoneyRange of type 1000000_4999999.
	MoneyRange10000004999999 MoneyRange = "1000000_4999999"
	// MoneyRange5000000Plus is a MoneyRange of type 5000000_plus.
	MoneyRange5000000Plus MoneyRange = "5000000_plus"
)

var ErrInvalidMoneyRange = fmt.Errorf("not a valid MoneyRange, try [%s]", strings.Join(_MoneyRangeNames, ", "))

var _MoneyRangeNames = []string{
	string(MoneyRange099999),
	string(MoneyRange100000499999),
	string(MoneyRange500000999999),
	string(MoneyRange10000004999999),
	string(MoneyRange5000000Plus),
}

// MoneyRangeNames returns a list of possible string values of MoneyRange.
func MoneyRangeNames() []string {
	tmp := make([]string, len(_MoneyRangeNames))
	copy(tmp, _MoneyRangeNames)
	return tmp
}

// String implements the Stringer interface.
func (x MoneyRange) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MoneyRange) IsValid() bool {
	_, err := ParseMoneyRange(string(x))
	return err == nil
}

var _MoneyRangeValue = map[string]MoneyRange{
	"0_99999":         MoneyRange099999,
	"100000_499999":   MoneyRange100000499999,
	"500000_999999":   MoneyRange500000999999,
	"1000000_4999999": MoneyRange10000004999999,
	"5000000_plus":    MoneyRange5000000Plus,
}

// ParseMoneyRange attempts to convert a string to a MoneyRange.
func ParseMoneyRange(name string) (MoneyRange, error) {
	if x, ok := _MoneyRangeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _MoneyRangeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return MoneyRange(""), fmt.Errorf("%s is %w", name, ErrInvalidMoneyRange)
}

// MarshalText implements the text marshaller method.
func (x MoneyRange) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *MoneyRange) UnmarshalText(text []byte) error {
	tmp, err := ParseMoneyRange(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *MoneyRange) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfFundsBusinessLoans is a SourceOfFunds of type business_loans.
	SourceOfFundsBusinessLoans SourceOfFunds = "business_loans"
	// SourceOfFundsGrants is a SourceOfFunds of type grants.
	SourceOfFundsGrants SourceOfFunds = "grants"
	// SourceOfFundsInterCompanyFunds is a SourceOfFunds of type inter_company_funds.
	SourceOfFundsInterCompanyFunds SourceOfFunds = "inter_company_funds"
	// SourceOfFundsInvestmentProceeds is a SourceOfFunds of type investment_proceeds.
	SourceOfFundsInvestmentProceeds SourceOfFunds = "investment_proceeds"
	// SourceOfFundsLegalSettlement is a SourceOfFunds of type legal_settlement.
	SourceOfFundsLegalSettlement SourceOfFunds = "legal_settlement"
	// SourceOfFundsOwnersCapital is a SourceOfFunds of type owners_capital.
	SourceOfFundsOwnersCapital SourceOfFunds = "owners_capital"
	// SourceOfFundsPensionRetirement is a SourceOfFunds of type pension_retirement.
	SourceOfFundsPensionRetirement SourceOfFunds = "pension_retirement"
	// SourceOfFundsSaleOfAssets is a SourceOfFunds of type sale_of_assets.
	SourceOfFundsSaleOfAssets SourceOfFunds = "sale_of_assets"
	// SourceOfFundsSalesOfGoodsAndServices is a SourceOfFunds of type sales_of_goods_and_services.
	SourceOfFundsSalesOfGoodsAndServices SourceOfFunds = "sales_of_goods_and_services"
	// SourceOfFundsTaxRefund is a SourceOfFunds of type tax_refund.
	SourceOfFundsTaxRefund SourceOfFunds = "tax_refund"
	// SourceOfFundsThirdPartyFunds is a SourceOfFunds of type third_party_funds.
	SourceOfFundsThirdPartyFunds SourceOfFunds = "third_party_funds"
	// SourceOfFundsTreasuryReserves is a SourceOfFunds of type treasury_reserves.
	SourceOfFundsTreasuryReserves SourceOfFunds = "treasury_reserves"
)

var ErrInvalidSourceOfFunds = fmt.Errorf("not a valid SourceOfFunds, try [%s]", strings.Join(_SourceOfFundsNames, ", "))

var _SourceOfFundsNames = []string{
	string(SourceOfFundsBusinessLoans),
	string(SourceOfFundsGrants),
	string(SourceOfFundsInterCompanyFunds),
	string(SourceOfFundsInvestmentProceeds),
	string(SourceOfFundsLegalSettlement),
	string(SourceOfFundsOwnersCapital),
	string(SourceOfFundsPensionRetirement),
	string(SourceOfFundsSaleOfAssets),
	string(SourceOfFundsSalesOfGoodsAndServices),
	string(SourceOfFundsTaxRefund),
	string(SourceOfFundsThirdPartyFunds),
	string(SourceOfFundsTreasuryReserves),
}

// SourceOfFundsNames returns a list of possible string values of SourceOfFunds.
func SourceOfFundsNames() []string {
	tmp := make([]string, len(_SourceOfFundsNames))
	copy(tmp, _SourceOfFundsNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfFunds) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfFunds) IsValid() bool {
	_, err := ParseSourceOfFunds(string(x))
	return err == nil
}

var _SourceOfFundsValue = map[string]SourceOfFunds{
	"business_loans":              SourceOfFundsBusinessLoans,
	"grants":                      SourceOfFundsGrants,
	"inter_company_funds":         SourceOfFundsInterCompanyFunds,
	"investment_proceeds":         SourceOfFundsInvestmentProceeds,
	"legal_settlement":            SourceOfFundsLegalSettlement,
	"owners_capital":              SourceOfFundsOwnersCapital,
	"pension_retirement":          SourceOfFundsPensionRetirement,
	"sale_of_assets":              SourceOfFundsSaleOfAssets,
	"sales_of_goods_and_services": SourceOfFundsSalesOfGoodsAndServices,
	"tax_refund":                  SourceOfFundsTaxRefund,
	"third_party_funds":           SourceOfFundsThirdPartyFunds,
	"treasury_reserves":           SourceOfFundsTreasuryReserves,
}

// ParseSourceOfFunds attempts to convert a string to a SourceOfFunds.
func ParseSourceOfFunds(name string) (SourceOfFunds, error) {
	if x, ok := _SourceOfFundsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfFundsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfFunds(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfFunds)
}

// MarshalText implements the text marshaller method.
func (x SourceOfFunds) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfFunds) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfFunds(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfFunds) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// SourceOfWealthBusinessDividendsOrProfits is a SourceOfWealth of type business_dividends_or_profits.
	SourceOfWealthBusinessDividendsOrProfits SourceOfWealth = "business_dividends_or_profits"
	// SourceOfWealthSaleOfBusiness is a SourceOfWealth of type sale_of_business.
	SourceOfWealthSaleOfBusiness SourceOfWealth = "sale_of_business"
	// SourceOfWealthInheritance is a SourceOfWealth of type inheritance.
	SourceOfWealthInheritance SourceOfWealth = "inheritance"
	// SourceOfWealthRealEstateInvestments is a SourceOfWealth of type real_estate_investments.
	SourceOfWealthRealEstateInvestments SourceOfWealth = "real_estate_investments"
	// SourceOfWealthInvestmentReturns is a SourceOfWealth of type investment_returns.
	SourceOfWealthInvestmentReturns SourceOfWealth = "investment_returns"
	// SourceOfWealthAccumulatedRevenue is a SourceOfWealth of type accumulated_revenue.
	SourceOfWealthAccumulatedRevenue SourceOfWealth = "accumulated_revenue"
	// SourceOfWealthOther is a SourceOfWealth of type other.
	SourceOfWealthOther SourceOfWealth = "other"
)

var ErrInvalidSourceOfWealth = fmt.Errorf("not a valid SourceOfWealth, try [%s]", strings.Join(_SourceOfWealthNames, ", "))

var _SourceOfWealthNames = []string{
	string(SourceOfWealthBusinessDividendsOrProfits),
	string(SourceOfWealthSaleOfBusiness),
	string(SourceOfWealthInheritance),
	string(SourceOfWealthRealEstateInvestments),
	string(SourceOfWealthInvestmentReturns),
	string(SourceOfWealthAccumulatedRevenue),
	string(SourceOfWealthOther),
}

// SourceOfWealthNames returns a list of possible string values of SourceOfWealth.
func SourceOfWealthNames() []string {
	tmp := make([]string, len(_SourceOfWealthNames))
	copy(tmp, _SourceOfWealthNames)
	return tmp
}

// String implements the Stringer interface.
func (x SourceOfWealth) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SourceOfWealth) IsValid() bool {
	_, err := ParseSourceOfWealth(string(x))
	return err == nil
}

var _SourceOfWealthValue = map[string]SourceOfWealth{
	"business_dividends_or_profits": SourceOfWealthBusinessDividendsOrProfits,
	"sale_of_business":              SourceOfWealthSaleOfBusiness,
	"inheritance":                   SourceOfWealthInheritance,
	"real_estate_investments":       SourceOfWealthRealEstateInvestments,
	"investment_returns":            SourceOfWealthInvestmentReturns,
	"accumulated_revenue":           SourceOfWealthAccumulatedRevenue,
	"other":                         SourceOfWealthOther,
}

// ParseSourceOfWealth attempts to convert a string to a SourceOfWealth.
func ParseSourceOfWealth(name string) (SourceOfWealth, error) {
	if x, ok := _SourceOfWealthValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SourceOfWealthValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SourceOfWealth(""), fmt.Errorf("%s is %w", name, ErrInvalidSourceOfWealth)
}

// MarshalText implements the text marshaller method.
func (x SourceOfWealth) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *SourceOfWealth) UnmarshalText(text []byte) error {
	tmp, err := ParseSourceOfWealth(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *SourceOfWealth) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TaxIDTypeSSN is a TaxIDType of type SSN.
	TaxIDTypeSSN TaxIDType = "SSN"
	// TaxIDTypeEIN is a TaxIDType of type EIN.
	TaxIDTypeEIN TaxIDType = "EIN"
	// TaxIDTypeTFN is a TaxIDType of type TFN.
	TaxIDTypeTFN TaxIDType = "TFN"
	// TaxIDTypeABN is a TaxIDType of type ABN.
	TaxIDTypeABN TaxIDType = "ABN"
	// TaxIDTypeACN is a TaxIDType of type ACN.
	TaxIDTypeACN TaxIDType = "ACN"
	// TaxIDTypeUTR is a TaxIDType of type UTR.
	TaxIDTypeUTR TaxIDType = "UTR"
	// TaxIDTypeNINO is a TaxIDType of type NINO.
	TaxIDTypeNINO TaxIDType = "NINO"
	// TaxIDTypeNRIC is a TaxIDType of type NRIC.
	TaxIDTypeNRIC TaxIDType = "NRIC"
	// TaxIDTypeFIN is a TaxIDType of type FIN.
	TaxIDTypeFIN TaxIDType = "FIN"
	// TaxIDTypeASDG is a TaxIDType of type ASDG.
	TaxIDTypeASDG TaxIDType = "ASDG"
	// TaxIDTypeITR is a TaxIDType of type ITR.
	TaxIDTypeITR TaxIDType = "ITR"
	// TaxIDTypeNIF is a TaxIDType of type NIF.
	TaxIDTypeNIF TaxIDType = "NIF"
	// TaxIDTypeTIN is a TaxIDType of type TIN.
	TaxIDTypeTIN TaxIDType = "TIN"
	// TaxIDTypeVAT is a TaxIDType of type VAT.
	TaxIDTypeVAT TaxIDType = "VAT"
	// TaxIDTypeCUIL is a TaxIDType of type CUIL.
	TaxIDTypeCUIL TaxIDType = "CUIL"
	// TaxIDTypeCUIT is a TaxIDType of type CUIT.
	TaxIDTypeCUIT TaxIDType = "CUIT"
	// TaxIDTypeDNI is a TaxIDType of type DNI.
	TaxIDTypeDNI TaxIDType = "DNI"
	// TaxIDTypeBIN is a TaxIDType of type BIN.
	TaxIDTypeBIN TaxIDType = "BIN"
	// TaxIDTypeUNP is a TaxIDType of type UNP.
	TaxIDTypeUNP TaxIDType = "UNP"
	// TaxIDTypeRNPM is a TaxIDType of type RNPM.
	TaxIDTypeRNPM TaxIDType = "RNPM"
	// TaxIDTypeNIT is a TaxIDType of type NIT.
	TaxIDTypeNIT TaxIDType = "NIT"
	// TaxIDTypeCPF is a TaxIDType of type CPF.
	TaxIDTypeCPF TaxIDType = "CPF"
	// TaxIDTypeCNPJ is a TaxIDType of type CNPJ.
	TaxIDTypeCNPJ TaxIDType = "CNPJ"
	// TaxIDTypeNIRE is a TaxIDType of type NIRE.
	TaxIDTypeNIRE TaxIDType = "NIRE"
	// TaxIDTypeUCN is a TaxIDType of type UCN.
	TaxIDTypeUCN TaxIDType = "UCN"
	// TaxIDTypeUIC is a TaxIDType of type UIC.
	TaxIDTypeUIC TaxIDType = "UIC"
	// TaxIDTypeSIN is a TaxIDType of type SIN.
	TaxIDTypeSIN TaxIDType = "SIN"
	// TaxIDTypeBN is a TaxIDType of type BN.
	TaxIDTypeBN TaxIDType = "BN"
	// TaxIDTypeRUT is a TaxIDType of type RUT.
	TaxIDTypeRUT TaxIDType = "RUT"
	// TaxIDTypeIIN is a TaxIDType of type IIN.
	TaxIDTypeIIN TaxIDType = "IIN"
	// TaxIDTypeUSCC is a TaxIDType of type USCC.
	TaxIDTypeUSCC TaxIDType = "USCC"
	// TaxIDTypeCNOC is a TaxIDType of type CNOC.
	TaxIDTypeCNOC TaxIDType = "CNOC"
	// TaxIDTypeUSCN is a TaxIDType of type USCN.
	TaxIDTypeUSCN TaxIDType = "USCN"
	// TaxIDTypeITIN is a TaxIDType of type ITIN.
	TaxIDTypeITIN TaxIDType = "ITIN"
	// TaxIDTypeCPJ is a TaxIDType of type CPJ.
	TaxIDTypeCPJ TaxIDType = "CPJ"
	// TaxIDTypeOIB is a TaxIDType of type OIB.
	TaxIDTypeOIB TaxIDType = "OIB"
	// TaxIDTypeDIC is a TaxIDType of type DIC.
	TaxIDTypeDIC TaxIDType = "DIC"
	// TaxIDTypeCPR is a TaxIDType of type CPR.
	TaxIDTypeCPR TaxIDType = "CPR"
	// TaxIDTypeCVR is a TaxIDType of type CVR.
	TaxIDTypeCVR TaxIDType = "CVR"
	// TaxIDTypeCN is a TaxIDType of type CN.
	TaxIDTypeCN TaxIDType = "CN"
	// TaxIDTypeRNC is a TaxIDType of type RNC.
	TaxIDTypeRNC TaxIDType = "RNC"
	// TaxIDTypeRUC is a TaxIDType of type RUC.
	TaxIDTypeRUC TaxIDType = "RUC"
	// TaxIDTypeTN is a TaxIDType of type TN.
	TaxIDTypeTN TaxIDType = "TN"
	// TaxIDTypeHETU is a TaxIDType of type HETU.
	TaxIDTypeHETU TaxIDType = "HETU"
	// TaxIDTypeYT is a TaxIDType of type YT.
	TaxIDTypeYT TaxIDType = "YT"
	// TaxIDTypeALV is a TaxIDType of type ALV.
	TaxIDTypeALV TaxIDType = "ALV"
	// TaxIDTypeSIREN is a TaxIDType of type SIREN.
	TaxIDTypeSIREN TaxIDType = "SIREN"
	// TaxIDTypeIDNR is a TaxIDType of type IDNR.
	TaxIDTypeIDNR TaxIDType = "IDNR"
	// TaxIDTypeSTNR is a TaxIDType of type STNR.
	TaxIDTypeSTNR TaxIDType = "STNR"
	// TaxIDTypeVTA is a TaxIDType of type VTA.
	TaxIDTypeVTA TaxIDType = "VTA"
	// TaxIDTypeHKID is a TaxIDType of type HKID.
	TaxIDTypeHKID TaxIDType = "HKID"
	// TaxIDTypeAJ is a TaxIDType of type AJ.
	TaxIDTypeAJ TaxIDType = "AJ"
	// TaxIDTypeEN is a TaxIDType of type EN.
	TaxIDTypeEN TaxIDType = "EN"
	// TaxIDTypeKN is a TaxIDType of type KN.
	TaxIDTypeKN TaxIDType = "KN"
	// TaxIDTypeVSK is a TaxIDType of type VSK.
	TaxIDTypeVSK TaxIDType = "VSK"
	// TaxIDTypePAN is a TaxIDType of type PAN.
	TaxIDTypePAN TaxIDType = "PAN"
	// TaxIDTypeGSTN is a TaxIDType of type GSTN.
	TaxIDTypeGSTN TaxIDType = "GSTN"
	// TaxIDTypeNIK is a TaxIDType of type NIK.
	TaxIDTypeNIK TaxIDType = "NIK"
	// TaxIDTypeNPWP is a TaxIDType of type NPWP.
	TaxIDTypeNPWP TaxIDType = "NPWP"
	// TaxIDTypePPS is a TaxIDType of type PPS.
	TaxIDTypePPS TaxIDType = "PPS"
	// TaxIDTypeTRN is a TaxIDType of type TRN.
	TaxIDTypeTRN TaxIDType = "TRN"
	// TaxIDTypeCRO is a TaxIDType of type CRO.
	TaxIDTypeCRO TaxIDType = "CRO"
	// TaxIDTypeCHY is a TaxIDType of type CHY.
	TaxIDTypeCHY TaxIDType = "CHY"
	// TaxIDTypeCF is a TaxIDType of type CF.
	TaxIDTypeCF TaxIDType = "CF"
	// TaxIDTypeIVA is a TaxIDType of type IVA.
	TaxIDTypeIVA TaxIDType = "IVA"
	// TaxIDTypeIN is a TaxIDType of type IN.
	TaxIDTypeIN TaxIDType = "IN"
	// TaxIDTypeJCT is a TaxIDType of type JCT.
	TaxIDTypeJCT TaxIDType = "JCT"
	// TaxIDTypeEDRPOU is a TaxIDType of type EDRPOU.
	TaxIDTypeEDRPOU TaxIDType = "EDRPOU"
	// TaxIDTypeEID is a TaxIDType of type EID.
	TaxIDTypeEID TaxIDType = "EID"
)

var ErrInvalidTaxIDType = fmt.Errorf("not a valid TaxIDType, try [%s]", strings.Join(_TaxIDTypeNames, ", "))

var _TaxIDTypeNames = []string{
	string(TaxIDTypeSSN),
	string(TaxIDTypeEIN),
	string(TaxIDTypeTFN),
	string(TaxIDTypeABN),
	string(TaxIDTypeACN),
	string(TaxIDTypeUTR),
	string(TaxIDTypeNINO),
	string(TaxIDTypeNRIC),
	string(TaxIDTypeFIN),
	string(TaxIDTypeASDG),
	string(TaxIDTypeITR),
	string(TaxIDTypeNIF),
	string(TaxIDTypeTIN),
	string(TaxIDTypeVAT),
	string(TaxIDTypeCUIL),
	string(TaxIDTypeCUIT),
	string(TaxIDTypeDNI),
	string(TaxIDTypeBIN),
	string(TaxIDTypeUNP),
	string(TaxIDTypeRNPM),
	string(TaxIDTypeNIT),
	string(TaxIDTypeCPF),
	string(TaxIDTypeCNPJ),
	string(TaxIDTypeNIRE),
	string(TaxIDTypeUCN),
	string(TaxIDTypeUIC),
	string(TaxIDTypeSIN),
	string(TaxIDTypeBN),
	string(TaxIDTypeRUT),
	string(TaxIDTypeIIN),
	string(TaxIDTypeUSCC),
	string(TaxIDTypeCNOC),
	string(TaxIDTypeUSCN),
	string(TaxIDTypeITIN),
	string(TaxIDTypeCPJ),
	string(TaxIDTypeOIB),
	string(TaxIDTypeDIC),
	string(TaxIDTypeCPR),
	string(TaxIDTypeCVR),
	string(TaxIDTypeCN),
	string(TaxIDTypeRNC),
	string(TaxIDTypeRUC),
	string(TaxIDTypeTN),
	string(TaxIDTypeHETU),
	string(TaxIDTypeYT),
	string(TaxIDTypeALV),
	string(TaxIDTypeSIREN),
	string(TaxIDTypeIDNR),
	string(TaxIDTypeSTNR),
	string(TaxIDTypeVTA),
	string(TaxIDTypeHKID),
	string(TaxIDTypeAJ),
	string(TaxIDTypeEN),
	string(TaxIDTypeKN),
	string(TaxIDTypeVSK),
	string(TaxIDTypePAN),
	string(TaxIDTypeGSTN),
	string(TaxIDTypeNIK),
	string(TaxIDTypeNPWP),
	string(TaxIDTypePPS),
	string(TaxIDTypeTRN),
	string(TaxIDTypeCRO),
	string(TaxIDTypeCHY),
	string(TaxIDTypeCF),
	string(TaxIDTypeIVA),
	string(TaxIDTypeIN),
	string(TaxIDTypeJCT),
	string(TaxIDTypeEDRPOU),
	string(TaxIDTypeEID),
}

// TaxIDTypeNames returns a list of possible string values of TaxIDType.
func TaxIDTypeNames() []string {
	tmp := make([]string, len(_TaxIDTypeNames))
	copy(tmp, _TaxIDTypeNames)
	return tmp
}

// String implements the Stringer interface.
func (x TaxIDType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TaxIDType) IsValid() bool {
	_, err := ParseTaxIDType(string(x))
	return err == nil
}

var _TaxIDTypeValue = map[string]TaxIDType{
	"SSN":    TaxIDTypeSSN,
	"ssn":    TaxIDTypeSSN,
	"EIN":    TaxIDTypeEIN,
	"ein":    TaxIDTypeEIN,
	"TFN":    TaxIDTypeTFN,
	"tfn":    TaxIDTypeTFN,
	"ABN":    TaxIDTypeABN,
	"abn":    TaxIDTypeABN,
	"ACN":    TaxIDTypeACN,
	"acn":    TaxIDTypeACN,
	"UTR":    TaxIDTypeUTR,
	"utr":    TaxIDTypeUTR,
	"NINO":   TaxIDTypeNINO,
	"nino":   TaxIDTypeNINO,
	"NRIC":   TaxIDTypeNRIC,
	"nric":   TaxIDTypeNRIC,
	"FIN":    TaxIDTypeFIN,
	"fin":    TaxIDTypeFIN,
	"ASDG":   TaxIDTypeASDG,
	"asdg":   TaxIDTypeASDG,
	"ITR":    TaxIDTypeITR,
	"itr":    TaxIDTypeITR,
	"NIF":    TaxIDTypeNIF,
	"nif":    TaxIDTypeNIF,
	"TIN":    TaxIDTypeTIN,
	"tin":    TaxIDTypeTIN,
	"VAT":    TaxIDTypeVAT,
	"vat":    TaxIDTypeVAT,
	"CUIL":   TaxIDTypeCUIL,
	"cuil":   TaxIDTypeCUIL,
	"CUIT":   TaxIDTypeCUIT,
	"cuit":   TaxIDTypeCUIT,
	"DNI":    TaxIDTypeDNI,
	"dni":    TaxIDTypeDNI,
	"BIN":    TaxIDTypeBIN,
	"bin":    TaxIDTypeBIN,
	"UNP":    TaxIDTypeUNP,
	"unp":    TaxIDTypeUNP,
	"RNPM":   TaxIDTypeRNPM,
	"rnpm":   TaxIDTypeRNPM,
	"NIT":    TaxIDTypeNIT,
	"nit":    TaxIDTypeNIT,
	"CPF":    TaxIDTypeCPF,
	"cpf":    TaxIDTypeCPF,
	"CNPJ":   TaxIDTypeCNPJ,
	"cnpj":   TaxIDTypeCNPJ,
	"NIRE":   TaxIDTypeNIRE,
	"nire":   TaxIDTypeNIRE,
	"UCN":    TaxIDTypeUCN,
	"ucn":    TaxIDTypeUCN,
	"UIC":    TaxIDTypeUIC,
	"uic":    TaxIDTypeUIC,
	"SIN":    TaxIDTypeSIN,
	"sin":    TaxIDTypeSIN,
	"BN":     TaxIDTypeBN,
	"bn":     TaxIDTypeBN,
	"RUT":    TaxIDTypeRUT,
	"rut":    TaxIDTypeRUT,
	"IIN":    TaxIDTypeIIN,
	"iin":    TaxIDTypeIIN,
	"USCC":   TaxIDTypeUSCC,
	"uscc":   TaxIDTypeUSCC,
	"CNOC":   TaxIDTypeCNOC,
	"cnoc":   TaxIDTypeCNOC,
	"USCN":   TaxIDTypeUSCN,
	"uscn":   TaxIDTypeUSCN,
	"ITIN":   TaxIDTypeITIN,
	"itin":   TaxIDTypeITIN,
	"CPJ":    TaxIDTypeCPJ,
	"cpj":    TaxIDTypeCPJ,
	"OIB":    TaxIDTypeOIB,
	"oib":    TaxIDTypeOIB,
	"DIC":    TaxIDTypeDIC,
	"dic":    TaxIDTypeDIC,
	"CPR":    TaxIDTypeCPR,
	"cpr":    TaxIDTypeCPR,
	"CVR":    TaxIDTypeCVR,
	"cvr":    TaxIDTypeCVR,
	"CN":     TaxIDTypeCN,
	"cn":     TaxIDTypeCN,
	"RNC":    TaxIDTypeRNC,
	"rnc":    TaxIDTypeRNC,
	"RUC":    TaxIDTypeRUC,
	"ruc":    TaxIDTypeRUC,
	"TN":     TaxIDTypeTN,
	"tn":     TaxIDTypeTN,
	"HETU":   TaxIDTypeHETU,
	"hetu":   TaxIDTypeHETU,
	"YT":     TaxIDTypeYT,
	"yt":     TaxIDTypeYT,
	"ALV":    TaxIDTypeALV,
	"alv":    TaxIDTypeALV,
	"SIREN":  TaxIDTypeSIREN,
	"siren":  TaxIDTypeSIREN,
	"IDNR":   TaxIDTypeIDNR,
	"idnr":   TaxIDTypeIDNR,
	"STNR":   TaxIDTypeSTNR,
	"stnr":   TaxIDTypeSTNR,
	"VTA":    TaxIDTypeVTA,
	"vta":    TaxIDTypeVTA,
	"HKID":   TaxIDTypeHKID,
	"hkid":   TaxIDTypeHKID,
	"AJ":     TaxIDTypeAJ,
	"aj":     TaxIDTypeAJ,
	"EN":     TaxIDTypeEN,
	"en":     TaxIDTypeEN,
	"KN":     TaxIDTypeKN,
	"kn":     TaxIDTypeKN,
	"VSK":    TaxIDTypeVSK,
	"vsk":    TaxIDTypeVSK,
	"PAN":    TaxIDTypePAN,
	"pan":    TaxIDTypePAN,
	"GSTN":   TaxIDTypeGSTN,
	"gstn":   TaxIDTypeGSTN,
	"NIK":    TaxIDTypeNIK,
	"nik":    TaxIDTypeNIK,
	"NPWP":   TaxIDTypeNPWP,
	"npwp":   TaxIDTypeNPWP,
	"PPS":    TaxIDTypePPS,
	"pps":    TaxIDTypePPS,
	"TRN":    TaxIDTypeTRN,
	"trn":    TaxIDTypeTRN,
	"CRO":    TaxIDTypeCRO,
	"cro":    TaxIDTypeCRO,
	"CHY":    TaxIDTypeCHY,
	"chy":    TaxIDTypeCHY,
	"CF":     TaxIDTypeCF,
	"cf":     TaxIDTypeCF,
	"IVA":    TaxIDTypeIVA,
	"iva":    TaxIDTypeIVA,
	"IN":     TaxIDTypeIN,
	"in":     TaxIDTypeIN,
	"JCT":    TaxIDTypeJCT,
	"jct":    TaxIDTypeJCT,
	"EDRPOU": TaxIDTypeEDRPOU,
	"edrpou": TaxIDTypeEDRPOU,
	"EID":    TaxIDTypeEID,
	"eid":    TaxIDTypeEID,
}

// ParseTaxIDType attempts to convert a string to a TaxIDType.
func ParseTaxIDType(name string) (TaxIDType, error) {
	if x, ok := _TaxIDTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TaxIDTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TaxIDType(""), fmt.Errorf("%s is %w", name, ErrInvalidTaxIDType)
}

// MarshalText implements the text marshaller method.
func (x TaxIDType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TaxIDType) UnmarshalText(text []byte) error {
	tmp, err := ParseTaxIDType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TaxIDType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
